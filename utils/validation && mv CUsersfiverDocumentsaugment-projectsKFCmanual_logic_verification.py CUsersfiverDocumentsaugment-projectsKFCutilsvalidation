"""
Logic Consistency Verification for SQZMOM + WaveTrend Strategy
Compares Pine Script logic with Jesse and VectorBT implementations
"""

import pandas as pd
import numpy as np
from typing import Dict, List, Tuple, Any

# Import all strategy implementations
from jesse.strategies.sqzmom_wavetrend_strategy import SQZMOMWaveTrendStrategy as JesseStrategy
from vectorbt.strategies.sqzmom_wavetrend_strategy import SQZMOMWaveTrendStrategy as VectorBTStrategy
from indicators.technical_indicators import (
    squeeze_momentum, wavetrend, get_momentum_color
)


class LogicConsistencyChecker:
    """
    Verifies logic consistency between different strategy implementations
    """
    
    def __init__(self):
        self.test_data = None
        self.pine_results = {}
        self.jesse_results = {}
        self.vectorbt_results = {}
        
    def generate_test_data(self, length: int = 100) -> pd.DataFrame:
        """
        Generate synthetic test data for consistency checking
        
        Args:
            length: Number of data points to generate
            
        Returns:
            DataFrame with OHLC data
        """
        np.random.seed(42)  # For reproducible results
        
        # Generate realistic price data
        base_price = 50000
        volatility = 0.02
        
        # Generate random walk with drift
        returns = np.random.normal(0.001, volatility, length)
        prices = [base_price]
        
        for ret in returns[1:]:
            prices.append(prices[-1] * (1 + ret))
        
        # Create OHLC data
        high_noise = np.random.uniform(1.0, 1.02, length)
        low_noise = np.random.uniform(0.98, 1.0, length)
        
        data = pd.DataFrame({
            'open': prices,
            'high': [p * h for p, h in zip(prices, high_noise)],
            'low': [p * l for p, l in zip(prices, low_noise)],
            'close': prices,
            'volume': np.random.randint(1000, 10000, length)
        })
        
        self.test_data = data
        return data
    
    def calculate_pine_indicators(self, data: pd.DataFrame) -> Dict[str, pd.Series]:
        """
        Calculate indicators exactly as in Pine Script
        
        Args:
            data: OHLC data
            
        Returns:
            Dictionary with all indicator series
        """
        close = data['close']
        high = data['high']
        low = data['low']
        
        # Pine Script default parameters
        bb_length = 20
        bb_mult = 2.0
        kc_length = 20
        kc_mult = 1.5
        use_true_range = True
        wt_channel_length = 10
        wt_avg_length = 21
        
        # Calculate indicators using the same functions as Pine Script
        sqz_on, sqz_off, no_sqz, momentum = squeeze_momentum(
            high, low, close, bb_length, bb_mult, kc_length, kc_mult, use_true_range
        )
        
        hlc3 = (high + low + close) / 3
        wt1, wt2 = wavetrend(hlc3, wt_channel_length, wt_avg_length)
        
        momentum_color = get_momentum_color(momentum)
        
        return {
            'sqz_on': sqz_on,
            'sqz_off': sqz_off,
            'no_sqz': no_sqz,
            'momentum': momentum,
            'wt1': wt1,
            'wt2': wt2,
            'momentum_color': momentum_color
        }
    
    def generate_pine_signals(self, indicators: Dict[str, pd.Series]) -> Dict[str, pd.Series]:
        """
        Generate signals exactly as in Pine Script
        
        Args:
            indicators: Dictionary with all indicator series
            
        Returns:
            Dictionary with signal series
        """
        sqz_on = indicators['sqz_on']
        momentum = indicators['momentum']
        wt1 = indicators['wt1']
        wt2 = indicators['wt2']
        momentum_color = indicators['momentum_color']
        no_sqz = indicators['no_sqz']
        
        # Previous values
        prev_sqz_on = sqz_on.shift(1)
        
        # Black cross signal (squeeze release)
        black_cross_raw = prev_sqz_on & ~sqz_on
        signal_bar_raw = black_cross_raw & ~no_sqz
        
        # Use confirmed signal (1-bar delay)
        black_cross = black_cross_raw.shift(1)
        signal_bar = signal_bar_raw.shift(1)
        
        # Long signals
        long_signal = signal_bar & (momentum > 0) & (wt1 > wt2)
        short_signal = signal_bar & (momentum < 0) & (wt1 < wt2)
        
        # Trade direction filter (both)
        long_signal_filtered = long_signal
        short_signal_filtered = short_signal
        
        return {
            'long_entries': long_signal_filtered,
            'short_entries': short_signal_filtered,
            'signal_bar': signal_bar,
            'black_cross': black_cross
        }
    
    def generate_jesse_signals(self, indicators: Dict[str, pd.Series]) -> Dict[str, pd.Series]:
        """
        Generate signals using Jesse strategy logic
        
        Args:
            indicators: Dictionary with all indicator series
            
        Returns:
            Dictionary with signal series
        """
        # This simulates the Jesse strategy logic
        sqz_on = indicators['sqz_on']
        momentum = indicators['momentum']
        wt1 = indicators['wt1']
        wt2 = indicators['wt2']
        no_sqz = indicators['no_sqz']
        
        # Previous values
        prev_sqz_on = sqz_on.shift(1)
        
        # Black cross signal
        black_cross_raw = prev_sqz_on & ~sqz_on
        signal_bar_raw = black_cross_raw & ~no_sqz
        
        # Jesse uses confirmed signal by default (use_confirmed_signal=False in default config)
        black_cross = black_cross_raw
        signal_bar = signal_bar_raw
        
        # Long signals
        long_signal = signal_bar & (momentum > 0) & (wt1 > wt2)
        short_signal = signal_bar & (momentum < 0) & (wt1 < wt2)
        
        return {
            'long_entries': long_signal,
            'short_entries': short_signal,
            'signal_bar': signal_bar,
            'black_cross': black_cross
        }
    
    def generate_vectorbt_signals(self, indicators: Dict[str, pd.Series]) -> Dict[str, pd.Series]:
        """
        Generate signals using VectorBT strategy logic
        
        Args:
            indicators: Dictionary with all indicator series
            
        Returns:
            Dictionary with signal series
        """
        # This simulates the VectorBT strategy logic
        sqz_on = indicators['sqz_on']
        momentum = indicators['momentum']
        wt1 = indicators['wt1']
        wt2 = indicators['wt2']
        no_sqz = indicators['no_sqz']
        
        # Previous values
        prev_sqz_on = sqz_on.shift(1)
        
        # Black cross signal
        black_cross_raw = prev_sqz_on & ~sqz_on
        signal_bar_raw = black_cross_raw & ~no_sqz
        
        # VectorBT default is use_confirmed_signal=False
        black_cross = black_cross_raw
        signal_bar = signal_bar_raw
        
        # Long signals
        long_signal = signal_bar & (momentum > 0) & (wt1 > wt2)
        short_signal = signal_bar & (momentum < 0) & (wt1 < wt2)
        
        return {
            'long_entries': long_signal,
            'short_entries': short_signal,
            'signal_bar': signal_bar,
            'black_cross': black_cross
        }
    
    def compare_signals(self, signals1: Dict[str, pd.Series], 
                       signals2: Dict[str, pd.Series], 
                       name1: str, name2: str) -> Dict[str, Any]:
        """
        Compare two sets of signals
        
        Args:
            signals1: First set of signals
            signals2: Second set of signals
            name1: Name of first signal set
            name2: Name of second signal set
            
        Returns:
            Dictionary with comparison results
        """
        results = {}
        
        for key in signals1.keys():
            if key in signals2:
                # Remove NaN values for comparison
                s1 = signals1[key].dropna()
                s2 = signals2[key].dropna()
                
                # Align indices
                s1, s2 = s1.align(s2, join='inner')
                
                # Calculate agreement
                agreement = (s1 == s2).mean()
                
                # Count disagreements
                disagreements = (s1 != s2).sum()
                
                results[key] = {
                    'agreement_rate': agreement,
                    'disagreement_count': disagreements,
                    'total_signals': len(s1),
                    'name1_signals': s1.sum(),
                    'name2_signals': s2.sum()
                }
        
        return results
    
    def run_consistency_check(self) -> Dict[str, Any]:
        """
        Run full consistency check
        
        Returns:
            Dictionary with all consistency results
        """
        # Generate test data
        data = self.generate_test_data()
        
        # Calculate indicators
        indicators = self.calculate_pine_indicators(data)
        
        # Generate signals for each implementation
        pine_signals = self.generate_pine_signals(indicators)
        jesse_signals = self.generate_jesse_signals(indicators)
        vectorbt_signals = self.generate_vectorbt_signals(indicators)
        
        # Store results
        self.pine_results = {'indicators': indicators, 'signals': pine_signals}
        self.jesse_results = {'indicators': indicators, 'signals': jesse_signals}
        self.vectorbt_results = {'indicators': indicators, 'signals': vectorbt_signals}
        
        # Compare signals
        pine_vs_jesse = self.compare_signals(pine_signals, jesse_signals, 'Pine', 'Jesse')
        pine_vs_vectorbt = self.compare_signals(pine_signals, vectorbt_signals, 'Pine', 'VectorBT')
        jesse_vs_vectorbt = self.compare_signals(jesse_signals, vectorbt_signals, 'Jesse', 'VectorBT')
        
        return {
            'test_data_length': len(data),
            'pine_vs_jesse': pine_vs_jesse,
            'pine_vs_vectorbt': pine_vs_vectorbt,
            'jesse_vs_vectorbt': jesse_vs_vectorbt,
            'overall_consistency': self._calculate_overall_consistency(pine_vs_jesse, pine_vs_vectorbt)
        }
    
    def _calculate_overall_consistency(self, pine_vs_jesse: Dict, pine_vs_vectorbt: Dict) -> float:
        """
        Calculate overall consistency score
        
        Args:
            pine_vs_jesse: Pine vs Jesse comparison results
            pine_vs_vectorbt: Pine vs VectorBT comparison results
            
        Returns:
            Overall consistency score (0-1)
        """
        agreements = []
        
        for comparison in [pine_vs_jesse, pine_vs_vectorbt]:
            for signal_type in comparison.values():
                agreements.append(signal_type['agreement_rate'])
        
        return np.mean(agreements) if agreements else 0.0
    
    def print_consistency_report(self, results: Dict[str, Any]):
        """
        Print detailed consistency report
        
        Args:
            results: Consistency check results
        """
        print("=== SQZMOM + WaveTrend Strategy Consistency Report ===\n")
        
        print(f"Test Data Length: {results['test_data_length']} bars\n")
        
        # Pine vs Jesse
        print("--- Pine Script vs Jesse Framework ---")
        for signal_type, stats in results['pine_vs_jesse'].items():
            print(f"{signal_type}:")
            print(f"  Agreement Rate: {stats['agreement_rate']:.2%}")
            print(f"  Disagreements: {stats['disagreement_count']}")
            print(f"  Pine Signals: {stats['name1_signals']}")
            print(f"  Jesse Signals: {stats['name2_signals']}")
            print()
        
        # Pine vs VectorBT
        print("--- Pine Script vs VectorBT Framework ---")
        for signal_type, stats in results['pine_vs_vectorbt'].items():
            print(f"{signal_type}:")
            print(f"  Agreement Rate: {stats['agreement_rate']:.2%}")
            print(f"  Disagreements: {stats['disagreement_count']}")
            print(f"  Pine Signals: {stats['name1_signals']}")
            print(f"  VectorBT Signals: {stats['name2_signals']}")
            print()
        
        # Overall consistency
        overall = results['overall_consistency']
        print(f"Overall Consistency Score: {overall:.2%}")
        
        if overall >= 0.95:
            print("✅ EXCELLENT: Strategies are highly consistent")
        elif overall >= 0.90:
            print("✅ GOOD: Strategies are mostly consistent")
        elif overall >= 0.80:
            print("⚠️  FAIR: Strategies have some inconsistencies")
        else:
            print("❌ POOR: Strategies have significant inconsistencies")


def main():
    """
    Main function to run consistency check
    """
    checker = LogicConsistencyChecker()
    results = checker.run_consistency_check()
    checker.print_consistency_report(results)
    
    return results


if __name__ == "__main__":
    main()