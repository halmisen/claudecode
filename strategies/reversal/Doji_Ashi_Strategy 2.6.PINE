// âŒ˜ SUMMARY:
// Type: strategy
// Purpose: Multi-filter trading strategy with market trend, relative strength, and volume confirmation
// Key Inputs: Market type (Stocks/Crypto), multiple filter toggles, MA trigger settings
// Strategy Logic: Combines multiple filters (market trend, daily trend, volume, VWAP, MA trigger) for precision trading
// Version: v2.6 Strategy (Converted from DOJI V2.6 indicator)
// Based on: indicators/oscillator/DOJI V2.6.PINE

//@version=5
strategy(title="Doji Ashi v2.6 Strategy 8.1", overlay=true, initial_capital=500, default_qty_type=strategy.percent_of_equity, default_qty_value=20, margin_long=25, margin_short=25, commission_type=strategy.commission.percent, commission_value=0.02)

// === MODE SELECTOR === //
market_type = input.string("Stocks", options=["Stocks", "Crypto"], title="Market Type Preset", tooltip="Choose 'Stocks' to enable filters relevant to equities (e.g. SPY comparison). Choose 'Crypto' to enable BTC market filter and crypto-optimized defaults.")
trade_direction = input.string("Both", options=["Long", "Short", "Both"], title="Trade Direction", tooltip="Choose 'Long' for long trades only, 'Short' for short trades only, or 'Both' for both directions.")

// === INPUT SETTINGS === //
// Raw inputs with constant defaults
enable_market_filter_input = input.bool(false, "Use Market Trend Filter (SPY/BTC)", tooltip="When enabled, trades are only taken if the market index (SPY or BTC) is trending in the same direction as the signal.")
enable_relative_strength_input = input.bool(false, "Use Relative Strength Filter", tooltip="When enabled, the asset must be outperforming the SPY (for longs) or underperforming (for shorts).")
enable_daily_trend_filter_input = input.bool(true, "Use Daily Trend Filter (Above SMAs)", tooltip="When enabled, trades are filtered based on daily trend strength determined by the 20, 50, and 200 SMAs.")
trend_mode = input.string("Strict", options=["Strict", "Flexible"], title="Daily Trend Filter Mode", tooltip="'Strict' requires all 3 SMAs aligned. 'Flexible' allows for 2 out of 3 to confirm trend direction.")
enable_volume_filter = input.bool(false, "Use Relative Volume Filter", tooltip="When enabled, trades require volume to be at least 20% above the 20-bar average.")
enable_time_filter = input.bool(false, "Ignore First Minutes of Market Open", tooltip="Skips trades in the first session minutes you specify to avoid early market volatility.")
ignore_hour = input.int(14, "Ignore Start Hour (UTC)", minval=0, maxval=23, tooltip="Hour of day in UTC to start ignoring trades.")
ignore_minute = input.int(30, "Ignore Start Minute (UTC)", minval=0, maxval=59, tooltip="Minute of hour to start ignoring trades.")
ignore_minutes = input.int(30, minval=1, title="Minutes to Ignore", tooltip="How many minutes to skip after market/session open.")
enable_vwap_filter_entry_input = input.bool(false, "Use VWAP for Entry Filter", tooltip="Ensures long trades only occur above VWAP and short trades below VWAP. Helps confirm intraday trend alignment.")
enable_entry_trigger = input.bool(true, "Use Entry Trigger", tooltip="Requires a momentum trigger using 3/8 MA crossover logic to enter trades.")
trigger_ma_type = input.string("EMA", options=["EMA", "ZLEMA", "HULL"], title="Trigger MA Type", tooltip="Determines the type of moving average used for the 3/8 crossover trigger: EMA, Zero-Lag EMA, or HULL MA.")
entry_mode = input.string("Above/Below", options=["Cross", "Above/Below"], title="3/8 MA Entry Mode", tooltip="'Cross' triggers signals on 3/8 MA crossover. 'Above/Below' keeps signals active while the fast MA remains above/below the slow MA.")
cooldown_bars = input.int(10, "Cooldown Bars Between Signals", minval=1, tooltip="Number of bars to wait after a signal before allowing another signal in the same direction. Helps prevent overtrading.")
show_market_strength = input.bool(false, "Show Market Filter Strength", tooltip="Display background color indicating market filter strength (SPY/BTC distance from SMA).")

// === SL/TP SETTINGS === //
atr_length = input.int(14, "ATR Period", minval=1, tooltip="Period for Average True Range calculation used in SL/TP placement.")
atr_multiplier = input.float(1.5, "ATR Multiplier", step=0.1, tooltip="Multiplier for ATR to determine Stop Loss distance. Higher values = wider stops.")
risk_reward_ratio = input.float(2.0, "Risk:Reward Ratio", step=0.1, tooltip="Take Profit distance as a multiple of Stop Loss distance. 2.0 means TP is 2x the SL distance.")

// === EXIT SETTINGS === //
use_trailing_stop = input.bool(false, "Use Trailing Stop", tooltip="Enable trailing stop loss for positions.")
trail_offset = input.float(1.0, "Trailing Offset (%)", step=0.1, tooltip="Percentage below/above highest high/lowest low for trailing stop.")
use_time_exit = input.bool(false, "Use Time-based Exit", tooltip="Close positions after specified number of bars.")
max_bars_in_trade = input.int(100, "Max Bars in Trade", minval=1, tooltip="Maximum number of bars to hold a position before closing.")

// === VISUALIZATION SETTINGS === //
show_sltp = input.bool(true, "Show SL/TP Levels", tooltip="Display Stop Loss and Take Profit levels based on ATR calculation when signals are triggered.")
sl_color = input.color(color.red, "SL Line Color", tooltip="Color for Stop Loss lines.")
tp_color = input.color(color.green, "TP Line Color", tooltip="Color for Take Profit lines.")
line_width = input.int(2, "SL/TP Line Width", minval=1, maxval=5, tooltip="Width of SL/TP lines on chart.")
plot_vwap = input.bool(true, "Show VWAP Line", tooltip="Display VWAP line on chart.")

// Override filters based on market type
use_btc_filter = market_type == "Crypto"
use_spy_filter = market_type == "Stocks"

enable_market_filter = use_btc_filter or (use_spy_filter and enable_market_filter_input)
enable_relative_strength = use_spy_filter and enable_relative_strength_input
enable_daily_trend_filter = enable_daily_trend_filter_input

// VWAP entry logic for all market types
enable_vwap_filter_entry = enable_vwap_filter_entry_input

// Time filter: custom session time logic
session_start = timestamp("UTC", year, month, dayofmonth, ignore_hour, ignore_minute)
valid_time = not enable_time_filter or (time >= session_start + ignore_minutes * 60 * 1000)

// === MARKET FILTER === //
spy = request.security("SPY", timeframe.period, close, lookahead=barmerge.lookahead_on)
spy_sma_20 = request.security("SPY", timeframe.period, ta.sma(close, 20), lookahead=barmerge.lookahead_on)
market_bullish_spy = spy > spy_sma_20
market_bearish_spy = spy < spy_sma_20

btc = request.security("BINANCE:BTCUSDT", timeframe.period, close, lookahead=barmerge.lookahead_on)
btc_sma_20 = request.security("BINANCE:BTCUSDT", timeframe.period, ta.sma(close, 20), lookahead=barmerge.lookahead_on)
market_bullish_btc = btc > btc_sma_20
market_bearish_btc = btc < btc_sma_20

market_bullish = use_btc_filter ? market_bullish_btc : market_bullish_spy
market_bearish = use_btc_filter ? market_bearish_btc : market_bearish_spy

// === RELATIVE STRENGTH FILTER === //
rel_strength = close / spy
rel_strength_sma = ta.sma(rel_strength, 20)
strong_vs_spy = rel_strength > rel_strength_sma
weak_vs_spy = rel_strength < rel_strength_sma

// Market filter strength visualization
market_filter_strength = use_btc_filter ? (btc - btc_sma_20) / btc_sma_20 * 100 : (spy - spy_sma_20) / spy_sma_20 * 100

// === DAILY TREND FILTER === //
daily_close = request.security(syminfo.tickerid, "D", close, lookahead=barmerge.lookahead_on)
daily_sma_20 = request.security(syminfo.tickerid, "D", ta.sma(close, 20), lookahead=barmerge.lookahead_on)
daily_sma_50 = request.security(syminfo.tickerid, "D", ta.sma(close, 50), lookahead=barmerge.lookahead_on)
daily_sma_200 = request.security(syminfo.tickerid, "D", ta.sma(close, 200), lookahead=barmerge.lookahead_on)

sma_20_pass = daily_close > daily_sma_20
sma_50_pass = daily_close > daily_sma_50
sma_200_pass = daily_close > daily_sma_200
sma_pass_count = (sma_20_pass ? 1 : 0) + (sma_50_pass ? 1 : 0) + (sma_200_pass ? 1 : 0)

daily_uptrend = (trend_mode == "Strict" and sma_pass_count == 3) or (trend_mode == "Flexible" and sma_pass_count >= 2)
daily_downtrend = (trend_mode == "Strict" and sma_pass_count == 0) or (trend_mode == "Flexible" and sma_pass_count <= 1)

// === RELATIVE VOLUME FILTER === //
avg_volume = ta.sma(volume, 20)
rel_volume = volume / avg_volume
high_rel_volume = rel_volume > 1.2

// === VWAP FILTER === //
vwap = ta.vwap
above_vwap = close > vwap
below_vwap = close < vwap

// === ENTRY TRIGGER (3/8 MA CROSS or STATE) === //
get_ma(src, length) => trigger_ma_type == "EMA" ? ta.ema(src, length) : trigger_ma_type == "ZLEMA" ? 2 * src - src[length] : trigger_ma_type == "HULL" ? ta.wma(2 * ta.wma(src, length / 2) - ta.wma(src, length), int(math.sqrt(length))) : na

ma_3 = get_ma(close, 3)
ma_8 = get_ma(close, 8)

ema_cross_up = entry_mode == "Cross" ? ta.crossover(ma_3, ma_8) : ma_3 > ma_8
ema_cross_down = entry_mode == "Cross" ? ta.crossunder(ma_3, ma_8) : ma_3 < ma_8

// === COOLDOWN LOGIC === //
var int lastLongBar = na
var int lastShortBar = na
var int longEntryBar = na
var int shortEntryBar = na

long_ok = na(lastLongBar) or bar_index - lastLongBar > cooldown_bars
short_ok = na(lastShortBar) or bar_index - lastShortBar > cooldown_bars

// === LONG SETUP CONDITIONS === //
long_conditions = long_ok and (not enable_market_filter or market_bullish) and (not enable_relative_strength or strong_vs_spy) and (not enable_daily_trend_filter or daily_uptrend) and (not enable_volume_filter or high_rel_volume) and valid_time and (not enable_vwap_filter_entry or above_vwap) and (not enable_entry_trigger or ema_cross_up)

// === SHORT SETUP CONDITIONS === //
short_conditions = short_ok and (not enable_market_filter or market_bearish) and (not enable_relative_strength or weak_vs_spy) and (not enable_daily_trend_filter or daily_downtrend) and (not enable_volume_filter or high_rel_volume) and valid_time and (not enable_vwap_filter_entry or below_vwap) and (not enable_entry_trigger or ema_cross_down)

// === SL/TP CALCULATIONS === //
atr_value = ta.atr(atr_length)

// For long positions
long_sl = close - atr_value * atr_multiplier
long_tp = close + (close - long_sl) * risk_reward_ratio

// For short positions  
short_sl = close + atr_value * atr_multiplier
short_tp = close - (short_sl - close) * risk_reward_ratio

// === STRATEGY EXECUTION === //
if long_conditions and (trade_direction == "Long" or trade_direction == "Both")
    strategy.entry("Long", strategy.long)
    longEntryBar := bar_index
    strategy.exit("Exit Long", "Long", limit=long_tp, stop=long_sl, 
                 trail_points=use_trailing_stop ? close * trail_offset / 100 / syminfo.mintick : na,
                 trail_offset=use_trailing_stop ? close * trail_offset / 100 / syminfo.mintick : na,
                 when=use_time_exit ? bar_index >= longEntryBar + max_bars_in_trade : true)
    lastLongBar := bar_index

if short_conditions and (trade_direction == "Short" or trade_direction == "Both")
    strategy.entry("Short", strategy.short)
    shortEntryBar := bar_index
    strategy.exit("Exit Short", "Short", limit=short_tp, stop=short_sl,
                 trail_points=use_trailing_stop ? close * trail_offset / 100 / syminfo.mintick : na,
                 trail_offset=use_trailing_stop ? close * trail_offset / 100 / syminfo.mintick : na,
                 when=use_time_exit ? bar_index >= shortEntryBar + max_bars_in_trade : true)
    lastShortBar := bar_index

// === ALERTS === //
alertcondition(long_conditions, title="Strategy Buy Alert", message="Doji Ashi Strategy Buy Signal on {{ticker}}")
alertcondition(short_conditions, title="Strategy Sell Alert", message="Doji Ashi Strategy Sell Signal on {{ticker}}")

// === PLOTS === //
plotshape(long_conditions, title="Long Entry", location=location.belowbar, color=color.green, style=shape.labelup, text="BUY", textcolor=color.white, size=size.normal)
plotshape(short_conditions, title="Short Entry", location=location.abovebar, color=color.red, style=shape.labeldown, text="SELL", textcolor=color.white, size=size.normal)

// VWAP Plot with option to hide
plot(plot_vwap ? vwap : na, title="VWAP", color=color.orange, linewidth=1)

// === SL/TP PLOTS === //
if show_sltp and long_conditions
    line.new(bar_index + 2, long_sl, bar_index + 12, long_sl, color=sl_color, width=line_width, style=line.style_dashed)
    line.new(bar_index + 2, long_tp, bar_index + 12, long_tp, color=tp_color, width=line_width, style=line.style_dashed)
    label.new(bar_index + 12, long_sl, "SL", style=label.style_label_left, color=sl_color, textcolor=color.white, size=size.tiny)
    label.new(bar_index + 12, long_tp, "TP", style=label.style_label_left, color=tp_color, textcolor=color.white, size=size.tiny)

if show_sltp and short_conditions
    line.new(bar_index + 2, short_sl, bar_index + 12, short_sl, color=sl_color, width=line_width, style=line.style_dashed)
    line.new(bar_index + 2, short_tp, bar_index + 12, short_tp, color=tp_color, width=line_width, style=line.style_dashed)
    label.new(bar_index + 12, short_sl, "SL", style=label.style_label_left, color=sl_color, textcolor=color.white, size=size.tiny)
    label.new(bar_index + 12, short_tp, "TP", style=label.style_label_left, color=tp_color, textcolor=color.white, size=size.tiny)

// === MARKET FILTER STRENGTH INDICATOR === //
bgcolor(show_market_strength and enable_market_filter ? (market_filter_strength > 0 ? color.new(color.green, 85) : color.new(color.red, 85)) : na, title="Market Filter Strength")

//â€“â€“â€“ Kelly Stats â€“â€“â€“
// This code block calculates and displays Kelly criterion statistics.
// It runs only on the last bar to collect data from all closed trades.

// Function to calculate the sample variance of a float array.
arrayVariance(src) =>
    float float_mean = array.avg(src)
    float float_sumOfSquares = 0.0
    for i = 0 to array.size(src) - 1
        float_sumOfSquares += math.pow(array.get(src, i) - float_mean, 2)
    int int_n = array.size(src)
    float result = int_n > 1 ? float_sumOfSquares / (int_n - 1) : 0.0
    result

// 1. Declare global arrays to store the return and outcome of each trade.
//    Use the 'var' keyword to ensure the array persists across bars.
var array<float> array_float_tradeReturns = array.new_float()
var array<bool> array_bool_tradeWins = array.new_bool()

// 2. Main logic block, executed only on the last historical bar.
if barstate.islast
    // Populate the arrays from all closed trades.
    if strategy.closedtrades > 0 and array.size(array_float_tradeReturns) == 0
        for i = 0 to strategy.closedtrades - 1
            // Calculate the initial capital of the trade for v5.
            float float_entryVal = strategy.closedtrades.entry_price(i) * strategy.closedtrades.size(i)
            // Avoid division by zero error if capital is not zero.
            if float_entryVal != 0
                // Calculate the percentage return of this trade.
                float float_tradeReturn = (strategy.closedtrades.profit(i) / float_entryVal) * 100
                // Store the return and win/loss outcome in the global arrays.
                array.push(array_float_tradeReturns, float_tradeReturn)
                array.push(array_bool_tradeWins, strategy.closedtrades.profit(i) > 0)

    // 3. If there is trade data, calculate Kelly criterion statistics.
    float float_meanReturn = na
    float float_varianceReturn = na
    float float_kellyFraction = na
    float float_winRate = na
    float float_avgWin = na
    float float_avgLoss = na

    if array.size(array_float_tradeReturns) > 0
        // Calculate basic statistics
        float_meanReturn := array.avg(array_float_tradeReturns)
        float_varianceReturn := arrayVariance(array_float_tradeReturns)
        
        // Calculate win rate
        int int_winCount = 0
        for i = 0 to array.size(array_bool_tradeWins) - 1
            if array.get(array_bool_tradeWins, i)
                int_winCount += 1
        float_winRate := int_winCount / array.size(array_bool_tradeWins)
        
        // Calculate average win and average loss
        float float_totalWins = 0.0
        float float_totalLosses = 0.0
        int int_winCount2 = 0
        int int_lossCount = 0
        
        for i = 0 to array.size(array_float_tradeReturns) - 1
            float float_return = array.get(array_float_tradeReturns, i)
            if float_return > 0
                float_totalWins += float_return
                int_winCount2 += 1
            else if float_return < 0
                float_totalLosses += math.abs(float_return)
                int_lossCount += 1
        
        float_avgWin := int_winCount2 > 0 ? float_totalWins / int_winCount2 : 0.0
        float_avgLoss := int_lossCount > 0 ? float_totalLosses / int_lossCount : 0.0
        
        // Calculate Kelly fraction using the standard formula: (bp - q) / b
        // Where b = avgWin / avgLoss (the net odds), p = winRate, q = 1 - winRate
        if float_avgLoss > 0 and float_winRate > 0 and float_winRate < 1
            float b = float_avgWin / float_avgLoss
            float p = float_winRate
            float q = 1 - p
            float_kellyFraction := (b * p - q) / b
            // Ensure Kelly fraction is not negative and cap at 100%
            float_kellyFraction := math.max(0, float_kellyFraction)
            float_kellyFraction := math.min(1.0, float_kellyFraction)

    // 4. Display statistics in a table on the chart.
    //    The table is created only once and updated on the last bar.
    var table table_kellyStats = table.new(position.top_left, 2, 7, border_width = 1)
    if barstate.islast
        // Table header
        table.cell(table_kellyStats, 0, 0, "Metric", bgcolor = color.new(color.blue, 75))
        table.cell(table_kellyStats, 1, 0, "Value", bgcolor = color.new(color.blue, 75))
        
        // Win rate
        table.cell(table_kellyStats, 0, 1, "Win Rate (%)")
        table.cell(table_kellyStats, 1, 1, str.tostring(float_winRate * 100, "0.00"))
        
        // Average win
        table.cell(table_kellyStats, 0, 2, "Avg Win (%)")
        table.cell(table_kellyStats, 1, 2, str.tostring(float_avgWin, "0.00"))
        
        // Average loss
        table.cell(table_kellyStats, 0, 3, "Avg Loss (%)")
        table.cell(table_kellyStats, 1, 3, str.tostring(float_avgLoss, "0.00"))
        
        // Average return
        table.cell(table_kellyStats, 0, 4, "Mean Return (%)")
        table.cell(table_kellyStats, 1, 4, str.tostring(float_meanReturn, "0.00"))
        
        // Return variance
        table.cell(table_kellyStats, 0, 5, "Return Variance")
        table.cell(table_kellyStats, 1, 5, str.tostring(float_varianceReturn, "0.00"))

        // Kelly fraction
        table.cell(table_kellyStats, 0, 6, "Kelly Fraction")
        table.cell(table_kellyStats, 1, 6, str.tostring(float_kellyFraction, "0.00"))