
// âŒ˜ SUMMARY:
// Type: strategy
// Purpose: Filter-based trading strategy with multiple confirmation layers
// Key Inputs: Market type, various filters (market, relative strength, daily trend, volume, time, VWAP), entry settings
// Outputs: Filtered entry signals, VWAP line, SL/TP visualization, Kelly stats
// Functions: Filter functions, MA calculations, Kelly criterion analysis
// Logic: Comprehensive filtering approach with multiple confirmation layers, uses MA triggers for timing, includes Kelly criterion for optimization

//@version=5
strategy(title="Doji Ashi v2.5 Strategy", overlay=true, initial_capital=500, default_qty_type=strategy.percent_of_equity, default_qty_value=20, margin_long=25, margin_short=25, commission_type=strategy.commission.percent, commission_value=0.02)

// === MODE SELECTOR === //
string_market_type = input.string("Stocks", options=["Stocks", "Crypto"], title="Market Type Preset", group="Filters")

// === INPUT SETTINGS === //
bool_enable_market_filter_input = input.bool(true, "Use Market Trend Filter (SPY/BTC)", group="Filters")
bool_enable_relative_strength_input = input.bool(true, "Use Relative Strength Filter", group="Filters")
bool_enable_daily_trend_filter_input = input.bool(true, "Use Daily Trend Filter (Above SMAs)", group="Filters")
string_trend_mode = input.string("Strict", options=["Strict", "Flexible"], title="Daily Trend Filter Mode", group="Filters")
bool_enable_volume_filter = input.bool(true, "Use Relative Volume Filter", group="Filters")
bool_enable_time_filter = input.bool(true, "Ignore First Minutes of Market Open", group="Filters")
int_ignore_hour = input.int(14, "Ignore Start Hour (UTC)", minval=0, maxval=23, group="Filters")
int_ignore_minute = input.int(30, "Ignore Start Minute (UTC)", minval=0, maxval=59, group="Filters")
int_ignore_minutes = input.int(30, minval=1, title="Minutes to Ignore", group="Filters")
bool_enable_vwap_filter_entry_input = input.bool(true, "Use VWAP for Entry Filter", group="Filters")
bool_enable_entry_trigger = input.bool(true, "Use Entry Trigger", group="Filters")
string_trigger_ma_type = input.string("ZLEMA", options=["EMA", "ZLEMA", "HULL"], title="Trigger MA Type", group="Filters")
string_entry_mode = input.string("Cross", options=["Cross", "Above/Below"], title="3/8 MA Entry Mode", group="Filters")
string_trade_direction = input.string("Both", options=["Long Only", "Short Only", "Both"], title="Trade Direction", group="Strategy Settings")
int_cooldown_bars = input.int(10, "Cooldown Bars Between Signals", minval=1, group="Strategy Settings")

// === SL/TP SETTINGS === //
int_atrLen = input.int(14, "ATR Length for SL", group="Strategy Settings")
float_atrMult = input.float(1.5, "ATR Multiplier for SL", group="Strategy Settings")
float_tpRR = input.float(2.0, "TP Risk:Reward Ratio", group="Strategy Settings")
bool_showSLTP = input.bool(true, "Show SL & TP Lines", group="Visuals")
color_slColor = input.color(color.red, "SL Line Color", group="Visuals")
color_tpColor = input.color(color.green, "TP Line Color", group="Visuals")
int_lineWidth = input.int(2, "Line Width", minval=1, maxval=5, group="Visuals")

// === OVERRIDES === //
bool_use_btc_filter = string_market_type == "Crypto"
bool_use_spy_filter = string_market_type == "Stocks"
bool_enable_market_filter = bool_use_btc_filter or (bool_use_spy_filter and bool_enable_market_filter_input)
bool_enable_relative_strength = bool_use_spy_filter and bool_enable_relative_strength_input
bool_enable_daily_trend_filter = bool_enable_daily_trend_filter_input
bool_enable_vwap_filter_entry = bool_enable_vwap_filter_entry_input

// === TIME FILTER === //
int_session_start = timestamp("UTC", year, month, dayofmonth, int_ignore_hour, int_ignore_minute)
bool_valid_time = not bool_enable_time_filter or (time >= int_session_start + int_ignore_minutes * 60 * 1000)

// === MARKET FILTER === //
float_spy = request.security("SPY", timeframe.period, close)
float_spy_sma_20 = request.security("SPY", timeframe.period, ta.sma(close, 20))
float_btc = request.security("BINANCE:BTCUSDT", timeframe.period, close)
float_btc_sma_20 = request.security("BINANCE:BTCUSDT", timeframe.period, ta.sma(close, 20))

bool_market_bullish = bool_use_btc_filter ? float_btc > float_btc_sma_20 : float_spy > float_spy_sma_20
bool_market_bearish = bool_use_btc_filter ? float_btc < float_btc_sma_20 : float_spy < float_spy_sma_20

// === RELATIVE STRENGTH === //
float_rel_strength = close / float_spy
float_rel_strength_sma = ta.sma(float_rel_strength, 20)
bool_strong_vs_spy = float_rel_strength > float_rel_strength_sma
bool_weak_vs_spy = float_rel_strength < float_rel_strength_sma

// === DAILY TREND === //
float_daily_close = request.security(syminfo.tickerid, "D", close)
float_daily_sma_20 = request.security(syminfo.tickerid, "D", ta.sma(close, 20))
float_daily_sma_50 = request.security(syminfo.tickerid, "D", ta.sma(close, 50))
float_daily_sma_200 = request.security(syminfo.tickerid, "D", ta.sma(close, 200))

int_sma_pass_count = (float_daily_close > float_daily_sma_20 ? 1 : 0) + (float_daily_close > float_daily_sma_50 ? 1 : 0) + (float_daily_close > float_daily_sma_200 ? 1 : 0)
bool_daily_uptrend = (string_trend_mode == "Strict" and int_sma_pass_count == 3) or (string_trend_mode == "Flexible" and int_sma_pass_count >= 2)
bool_daily_downtrend = (string_trend_mode == "Strict" and int_sma_pass_count == 0) or (string_trend_mode == "Flexible" and int_sma_pass_count <= 1)

// === REL VOLUME === //
float_avg_vol = ta.sma(volume, 20)
bool_high_vol = volume > float_avg_vol * 1.2

// === VWAP === //
float_vwap = ta.vwap
bool_above_vwap = close > float_vwap
bool_below_vwap = close < float_vwap

// === MA TRIGGER === //
get_ma(src, len) =>
    string_trigger_ma_type == "EMA" ? ta.ema(src, len) : string_trigger_ma_type == "ZLEMA" ? 2 * src - src[len] : string_trigger_ma_type == "HULL" ? ta.wma(2 * ta.wma(src, len / 2) - ta.wma(src, len), int(math.sqrt(len))) : na

float_ma3 = get_ma(close, 3)
float_ma8 = get_ma(close, 8)

bool_trigger_up = string_entry_mode == "Cross" ? ta.crossover(float_ma3, float_ma8) : float_ma3 > float_ma8
bool_trigger_down = string_entry_mode == "Cross" ? ta.crossunder(float_ma3, float_ma8) : float_ma3 < float_ma8

// === COOLDOWN LOGIC === //
var int int_lastLongBar = na
var int int_lastShortBar = na

bool_long_ok = na(int_lastLongBar) or bar_index - int_lastLongBar > int_cooldown_bars
bool_short_ok = na(int_lastShortBar) or bar_index - int_lastShortBar > int_cooldown_bars

// === FINAL CONDITIONS === //
bool_long_cond = bool_long_ok and (not bool_enable_market_filter or bool_market_bullish) and (not bool_enable_relative_strength or bool_strong_vs_spy) and (not bool_enable_daily_trend_filter or bool_daily_uptrend) and (not bool_enable_volume_filter or bool_high_vol) and bool_valid_time and (not bool_enable_vwap_filter_entry or bool_above_vwap) and (not bool_enable_entry_trigger or bool_trigger_up)
bool_short_cond = bool_short_ok and (not bool_enable_market_filter or bool_market_bearish) and (not bool_enable_relative_strength or bool_weak_vs_spy) and (not bool_enable_daily_trend_filter or bool_daily_downtrend) and (not bool_enable_volume_filter or bool_high_vol) and bool_valid_time and (not bool_enable_vwap_filter_entry or bool_below_vwap) and (not bool_enable_entry_trigger or bool_trigger_down)

// === STRATEGY EXECUTION === //
float_atr_val = ta.atr(int_atrLen)
float_sl_points = float_atr_val * float_atrMult
float_tp_points = float_sl_points * float_tpRR

bool_allow_long = string_trade_direction == "Long Only" or string_trade_direction == "Both"
bool_allow_short = string_trade_direction == "Short Only" or string_trade_direction == "Both"

if (bool_long_cond and strategy.position_size == 0 and bool_allow_long)
    strategy.entry("Long", strategy.long)
    int_lastLongBar := bar_index

if (bool_short_cond and strategy.position_size == 0 and bool_allow_short)
    strategy.entry("Short", strategy.short)
    int_lastShortBar := bar_index

// Set SL/TP for open positions
if strategy.position_size > 0
    strategy.exit("Exit Long", "Long", loss=float_sl_points / syminfo.mintick, profit=float_tp_points / syminfo.mintick)

if strategy.position_size < 0
    strategy.exit("Exit Short", "Short", loss=float_sl_points / syminfo.mintick, profit=float_tp_points / syminfo.mintick)

// === PLOTS === //
plotshape(bool_long_cond, title="Long Signal", style=shape.labelup, location = location.belowbar, color=color.green, text="BUY", textcolor=color.white)
plotshape(bool_short_cond, title="Short Signal", style=shape.labeldown, location = location.abovebar, color=color.red, text="SELL", textcolor=color.white)
plot(float_vwap, "VWAP", color=color.orange)

// === SL/TP === //
float_atr = ta.atr(int_atrLen)
float_bullSL = close - float_atr * float_atrMult
float_bullTP = close + (close - float_bullSL) * float_tpRR
float_bearSL = close + float_atr * float_atrMult
float_bearTP = close - (float_bearSL - close) * float_tpRR

if bool_showSLTP and bool_long_cond
    line.new(bar_index + 2 , float_bullSL, bar_index + 12, float_bullSL, color=color_slColor, width=int_lineWidth)
    line.new(bar_index + 2, float_bullTP, bar_index + 12, float_bullTP, color=color_tpColor, width=int_lineWidth)
    label.new(bar_index + 12, float_bullSL, "SL", style = label.style_label_left, color = color_slColor, textcolor = color.white, size = size.tiny)
    label.new(bar_index + 12, float_bullTP, "TP", style = label.style_label_left, color = color_tpColor, textcolor = color.white, size = size.tiny)
if bool_showSLTP and bool_short_cond
    line.new(bar_index + 2, float_bearSL, bar_index + 12, float_bearSL, color=color_slColor, width=int_lineWidth)
    line.new(bar_index + 2, float_bearTP, bar_index + 12, float_bearTP, color=color_tpColor, width=int_lineWidth)
    label.new(bar_index + 12, float_bearSL, "SL", style = label.style_label_left, color = color_slColor, textcolor = color.white, size = size.tiny)
    label.new(bar_index + 12, float_bearTP, "TP", style = label.style_label_left, color = color_tpColor, textcolor = color.white, size = size.tiny)

//â€“â€“â€“ Kelly Stats â€“â€“â€“
// This code block calculates and displays Kelly criterion statistics.
// It runs only on the last bar to collect data from all closed trades.

// Function to calculate the sample variance of a float array.
arrayVariance(src) =>
    float float_mean = array.avg(src)
    float float_sumOfSquares = 0.0
    for i = 0 to array.size(src) - 1
        float_sumOfSquares += math.pow(array.get(src, i) - float_mean, 2)
    int int_n = array.size(src)
    float result = int_n > 1 ? float_sumOfSquares / (int_n - 1) : 0.0
    result

// 1. Declare a global array to store the return of each trade.
//    Use the 'var' keyword to ensure the array persists across bars.
var array<float> array_float_tradeReturns = array.new_float()

// 2. Main logic block, executed only on the last historical bar.
if barstate.islast
    // Populate the array from all closed trades.
    if strategy.closedtrades > 0 and array.size(array_float_tradeReturns) == 0
        for i = 0 to strategy.closedtrades - 1
            // Calculate the initial capital of the trade for v5.
            float float_entryVal = strategy.closedtrades.entry_price(i) * strategy.closedtrades.size(i)
            // Avoid division by zero error if capital is not zero.
            if float_entryVal != 0
                // Calculate the percentage return of this trade.
                float float_tradeReturn = (strategy.closedtrades.profit(i) / float_entryVal) * 100
                // Store the return in the global array.
                array.push(array_float_tradeReturns, float_tradeReturn)

    // 3. If there is trade data, calculate Kelly criterion statistics.
    float float_meanReturn = na
    float float_varianceReturn = na
    float float_kellyFraction = na

    if array.size(array_float_tradeReturns) > 0
        // Calculate the average return (average profit percentage per trade).
        float_meanReturn := array.avg(array_float_tradeReturns)
        // Calculate the variance of returns (sample variance) using the custom function.
        float_varianceReturn := arrayVariance(array_float_tradeReturns)
        // Calculate the Kelly fraction, handling the case where variance is zero.
        if float_varianceReturn != 0
            float_kellyFraction := float_meanReturn / float_varianceReturn

    // 4. Display statistics in a table on the chart.
    //    The table is created only once and updated on the last bar.
    var table table_kellyStats = table.new(position.top_left, 2, 4, border_width = 1)
    if barstate.islast
        // Table header
        table.cell(table_kellyStats, 0, 0, "Metric", bgcolor = color.new(color.blue, 75))
        table.cell(table_kellyStats, 1, 0, "Value", bgcolor = color.new(color.blue, 75))
        
        // Average return
        table.cell(table_kellyStats, 0, 1, "Mean Return (%)")
        table.cell(table_kellyStats, 1, 1, str.tostring(float_meanReturn, "0.00"))
        
        // Return variance
        table.cell(table_kellyStats, 0, 2, "Return Variance")
        table.cell(table_kellyStats, 1, 2, str.tostring(float_varianceReturn, "0.00"))

        // Kelly fraction
        table.cell(table_kellyStats, 0, 3, "Kelly Fraction")
        table.cell(table_kellyStats, 1, 3, str.tostring(float_kellyFraction, "0.00"))
