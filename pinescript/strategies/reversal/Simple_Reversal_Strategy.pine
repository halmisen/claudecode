// âŒ˜ SUMMARY:
// Type: strategy
// Purpose: Simple reversal trading strategy based on candle patterns and swing points
// Key Inputs: Trade direction, ATR SL/TP settings, fixed percentage options
// Outputs: Buy/sell signals, Kelly criterion statistics
// Functions: Pattern detection, ATR calculations, Kelly criterion analysis
// Logic: Identifies reversal patterns at swing points, uses ATR or fixed percentage for risk management, includes Kelly criterion for position sizing

//@version=5
// Â© Dreadblitz
// Simple Reversal Point Strategy
strategy("Simple Reversal Point Strategy", shorttitle="SRP Strategy", overlay=true, initial_capital=500, default_qty_type=strategy.percent_of_equity, default_qty_value=20, margin_long=25, margin_short=25, commission_type=strategy.commission.percent, commission_value=0.02)

// === Strategy Options ===
// Trade direction
string string_tradeDirection = input.string("Both", "Trade Direction", options=["Long Only", "Short Only", "Both"])

// ATR-based stop loss and take profit
bool bool_useAtr = input.bool(true, "Use ATR-based Stop Loss/Take Profit")
int int_atrLength = input.int(14, "ATR Period", minval=1)
float float_atrMultiplierSl = input.float(1.0, "ATR SL Multiplier", minval=0.1)
float float_atrRiskReward = input.float(2.0, "ATR Risk/Reward Ratio", minval=0.1)

// Fixed percentage stop loss and take profit
bool bool_useFixedPercent = input.bool(false, "Use Fixed Percentage Stop Loss/Take Profit")
float float_stopLossPercentRaw = input.float(1.0, "Stop Loss %", minval=0.1)
float float_takeProfitPercentRaw = input.float(2.0, "Take Profit %", minval=0.1)
float float_stopLossPercent = float_stopLossPercentRaw / 100
float float_takeProfitPercent = float_takeProfitPercentRaw / 100

// === Signal Conditions ===
// Buy signal conditions
bool bool_buyCond1 = close[1] < open[1] and close > open
bool bool_buyCond2 = close > open[1]
bool bool_buyCond3 = ta.lowest(low, 3) < ta.lowest(low, 50)[1] or ta.lowest(low, 3) < ta.lowest(low, 50)[2] or ta.lowest(low, 3) < ta.lowest(low, 50)[3]
bool bool_buySignal = bool_buyCond1 and bool_buyCond2 and bool_buyCond3

// Sell signal conditions
bool bool_sellCond1 = close[1] > open[1] and close < open
bool bool_sellCond2 = close < open[1]
bool bool_sellCond3 = ta.highest(high, 3) > ta.highest(high, 50)[1] or ta.highest(high, 3) > ta.highest(high, 50)[2] or ta.highest(high, 3) > ta.highest(high, 50)[3]
bool bool_sellSignal = bool_sellCond1 and bool_sellCond2 and bool_sellCond3

// === Trade Execution ===
// Trade direction filtering
bool bool_isBuySignal = bool_buySignal and (string_tradeDirection == "Long Only" or string_tradeDirection == "Both")
bool bool_isSellSignal = bool_sellSignal and (string_tradeDirection == "Short Only" or string_tradeDirection == "Both")

// ATR calculation
float float_atr = ta.atr(int_atrLength)

// Visualization
plotshape(bool_isBuySignal, text='ðŸ’£', style=shape.arrowup, location=location.belowbar, color=color.new(color.green, 0), textcolor=color.white, offset=0, size=size.auto)
plotshape(bool_isSellSignal, text='ðŸ”¨', style=shape.arrowdown, location=location.abovebar, color=color.new(color.red, 0), textcolor=color.white, offset=0, size=size.auto)

// Strategy execution with one position at a time
if (bool_isBuySignal and strategy.position_size == 0)
    strategy.entry("Long", strategy.long)
    
if (bool_isSellSignal and strategy.position_size == 0)
    strategy.entry("Short", strategy.short)

// === Exit Conditions ===
// Exit conditions - ATR based
if (bool_useAtr and strategy.position_size > 0)
    float float_entryPrice = strategy.position_avg_price
    float float_stopLossPrice = float_entryPrice - float_atr * float_atrMultiplierSl
    float float_takeProfitPrice = float_entryPrice + float_atr * float_atrMultiplierSl * float_atrRiskReward
    strategy.exit("Exit Long", "Long", stop=float_stopLossPrice, limit=float_takeProfitPrice)

if (bool_useAtr and strategy.position_size < 0)
    float float_entryPrice = strategy.position_avg_price
    float float_stopLossPrice = float_entryPrice + float_atr * float_atrMultiplierSl
    float float_takeProfitPrice = float_entryPrice - float_atr * float_atrMultiplierSl * float_atrRiskReward
    strategy.exit("Exit Short", "Short", stop=float_stopLossPrice, limit=float_takeProfitPrice)

// Exit conditions - Fixed percentage
if (bool_useFixedPercent and strategy.position_size > 0)
    float float_entryPrice = strategy.position_avg_price
    float float_stopLossPrice = float_entryPrice * (1 - float_stopLossPercent)
    float float_takeProfitPrice = float_entryPrice * (1 + float_takeProfitPercent)
    strategy.exit("Exit Long %", "Long", stop=float_stopLossPrice, limit=float_takeProfitPrice)

if (bool_useFixedPercent and strategy.position_size < 0)
    float float_entryPrice = strategy.position_avg_price
    float float_stopLossPrice = float_entryPrice * (1 + float_stopLossPercent)
    float float_takeProfitPrice = float_entryPrice * (1 - float_takeProfitPercent)
    strategy.exit("Exit Short %", "Short", stop=float_stopLossPrice, limit=float_takeProfitPrice)

// === Alerts ===
alertcondition(bool_isSellSignal, title="Sell", message="Sell")
alertcondition(bool_isBuySignal, title="Buy", message="Buy")
alertcondition(bool_isBuySignal or bool_isSellSignal, title="Buy/Sell", message="Buy/Sell")

//â€“â€“â€“ Kelly Stats â€“â€“â€“
// This code block calculates and displays Kelly criterion statistics.
// It runs only on the last bar to collect data from all closed trades.

// Function to calculate the sample variance of a float array.
arrayVariance(src) =>
    float float_mean = array.avg(src)
    float float_sumOfSquares = 0.0
    for i = 0 to array.size(src) - 1
        float_sumOfSquares += math.pow(array.get(src, i) - float_mean, 2)
    int int_n = array.size(src)
    float result = int_n > 1 ? float_sumOfSquares / (int_n - 1) : 0.0
    result

// 1. Declare a global array to store the return of each trade.
//    Use the 'var' keyword to ensure the array persists across bars.
var array<float> array_float_tradeReturns = array.new_float()

// 2. Main logic block, executed only on the last historical bar.
if barstate.islast
    // Populate the array from all closed trades.
    // This loop runs once at the end of backtesting.
    if strategy.closedtrades > 0 and array.size(array_float_tradeReturns) == 0
        for i = 0 to strategy.closedtrades - 1
            // Calculate the initial capital of the trade for v5.
            float float_entryVal = strategy.closedtrades.entry_price(i) * math.abs(strategy.closedtrades.size(i))
            // Avoid division by zero error if capital is not zero.
            if float_entryVal != 0
                // Calculate the percentage return of this trade.
                float float_tradeReturn = (strategy.closedtrades.profit(i) / float_entryVal) * 100
                // Store the return in the global array.
                array.push(array_float_tradeReturns, float_tradeReturn)

    // 3. If there is trade data, calculate Kelly criterion statistics.
    float float_meanReturn = na
    float float_varianceReturn = na
    float float_kellyFraction = na

    if array.size(array_float_tradeReturns) > 0
        // Calculate the average return (average profit percentage per trade).
        float_meanReturn := array.avg(array_float_tradeReturns)
        // Calculate the variance of returns (sample variance) using the custom function.
        float_varianceReturn := arrayVariance(array_float_tradeReturns)
        // Calculate the Kelly fraction, handling the case where variance is zero.
        if float_varianceReturn != 0
            float_kellyFraction := float_meanReturn / float_varianceReturn

    // 4. Display statistics in a table on the chart.
    //    The table is created only once and updated on the last bar.
    var table table_kellyStats = table.new(position.top_left, 2, 4, border_width = 1)
    if barstate.islast
        // Table header
        table.cell(table_kellyStats, 0, 0, "Metric", bgcolor = color.new(color.blue, 75))
        table.cell(table_kellyStats, 1, 0, "Value", bgcolor = color.new(color.blue, 75))
        
        // Average return
        table.cell(table_kellyStats, 0, 1, "Mean Return (%)")
        table.cell(table_kellyStats, 1, 1, str.tostring(float_meanReturn, "0.00"))
        
        // Return variance
        table.cell(table_kellyStats, 0, 2, "Return Variance")
        table.cell(table_kellyStats, 1, 2, str.tostring(float_varianceReturn, "0.00"))

        // Kelly fraction
        table.cell(table_kellyStats, 0, 3, "Kelly Fraction")
        table.cell(table_kellyStats, 1, 3, str.tostring(float_kellyFraction, "0.00"))
