// ⌘ SUMMARY:
// Type: strategy
// Purpose: Combined Squeeze Momentum and WaveTrend filter strategy
// Key Inputs: SQZMOM parameters, WaveTrend settings, trade direction, stop loss options
// Outputs: Entry signals with WaveTrend confirmation, exit signals, Kelly statistics
// Functions: SQZMOM calculations, WaveTrend indicator, state management for exits
// Logic: Enters on squeeze release confirmed by WaveTrend, uses sophisticated exit logic based on momentum strength or squeeze re-entry

//@version=5
strategy(title="SQZMOM+WT Strat", shorttitle="SQZMOM+WT Strat", overlay=true, initial_capital=500, default_qty_type=strategy.percent_of_equity, default_qty_value=20, margin_long=25, margin_short=25, commission_type=strategy.commission.percent, commission_value=0.02)

// === Inputs ===

// --- SQZMOM Inputs ---
int int_length = input.int(20, title="BB Length", group="Squeeze Momentum")
float float_mult = input.float(2.0, title="BB MultFactor", group="Squeeze Momentum")
int int_lengthKC = input.int(20, title="KC Length", group="Squeeze Momentum")
float float_multKC = input.float(1.5, title="KC MultFactor", group="Squeeze Momentum")
bool bool_useTrueRange = input.bool(true, title="Use TrueRange (KC)", group="Squeeze Momentum")
bool bool_useConfirmedSignal = input.bool(false, title="Use Delayed Confirmed Signal", tooltip="Wait 1 bar to confirm signal (prevents repainting)", group="Squeeze Momentum")

// --- WaveTrend Inputs ---
int int_n1 = input.int(10, "WT Channel Length", group="WaveTrend Filter")
int int_n2 = input.int(21, "WT Average Length", group="WaveTrend Filter")

// --- Strategy Inputs ---
string string_tradeDirection = input.string("Both", title="Trade Direction", options=["Long Only", "Short Only", "Both"], group="Strategy Settings")
bool bool_useStopLoss = input.bool(false, title="Use Stop Loss", group="Strategy Settings")
float float_stopLossPercent = input.float(2.0, title="Stop Loss Percent", step=0.1, group="Strategy Settings")


// === Calculations ===

// --- SQZMOM Calculations ---
float float_source = close
float float_basis = ta.sma(float_source, int_length)
float float_dev = float_mult * ta.stdev(float_source, int_length)
float float_upperBB = float_basis + float_dev
float float_lowerBB = float_basis - float_dev

float float_ma = ta.sma(float_source, int_lengthKC)
float float_kcRange = bool_useTrueRange ? ta.tr : (high - low)
float float_rangema = ta.sma(float_kcRange, int_lengthKC)
float float_upperKC = float_ma + float_rangema * float_multKC
float float_lowerKC = float_ma - float_rangema * float_multKC

bool bool_sqzOn = (float_lowerBB > float_lowerKC) and (float_upperBB < float_upperKC)
bool bool_sqzOff = (float_lowerBB < float_lowerKC) and (float_upperBB > float_upperKC)
bool bool_noSqz = not bool_sqzOn and not bool_sqzOff

float float_val = ta.linreg(float_source - ((ta.highest(high, int_lengthKC) + ta.lowest(low, int_lengthKC)) / 2 + ta.sma(close, int_lengthKC)) / 2, int_lengthKC, 0)
color color_bcolor = float_val > 0 ? (float_val > nz(float_val[1]) ? color.lime : color.green) : (float_val < nz(float_val[1]) ? color.red : color.maroon)

// --- WaveTrend Calculations ---
float float_ap = hlc3
float float_esa = ta.ema(float_ap, int_n1)
float float_d = ta.ema(math.abs(float_ap - float_esa), int_n1)
float float_ci = (float_ap - float_esa) / (0.015 * float_d)
float float_tci = ta.ema(float_ci, int_n2)

float float_wt1 = float_tci
float float_wt2 = ta.sma(float_wt1, 4)


// === Signal Conditions ===

// --- Entry Signals ---
bool bool_blackCross_raw = bool_sqzOn[1] and not bool_sqzOn
bool bool_signalBar_raw = bool_blackCross_raw and not bool_noSqz

bool bool_blackCross = bool_useConfirmedSignal ? bool_blackCross_raw[1] : bool_blackCross_raw
bool bool_signalBar = bool_useConfirmedSignal ? bool_signalBar_raw[1] : bool_signalBar_raw

bool bool_longSignal = bool_signalBar and float_val > 0 and float_wt1 > float_wt2
bool bool_shortSignal = bool_signalBar and float_val < 0 and float_wt1 < float_wt2

bool bool_longSignalFiltered = (string_tradeDirection != "Short Only") and bool_longSignal
bool bool_shortSignalFiltered = (string_tradeDirection != "Long Only") and bool_shortSignal

// --- State Tracking for Exits ---
var bool bool_waitLongExitBySqueeze = false
var bool bool_waitShortExitBySqueeze = false

// On a new long entry, decide which exit condition to wait for.
if (bool_longSignalFiltered and strategy.position_size == 0)
    bool_waitLongExitBySqueeze := color_bcolor == color.green

// On a new short entry, decide which exit condition to wait for.
if (bool_shortSignalFiltered and strategy.position_size == 0)
    bool_waitShortExitBySqueeze := color_bcolor == color.maroon

// --- Exit Signals ---
// Exit a long position if momentum weakens.
bool bool_exitLongWeak = strategy.position_size > 0 and not bool_waitLongExitBySqueeze and color_bcolor == color.green and color_bcolor[1] == color.lime

// Exit a short position if momentum weakens.
bool bool_exitShortWeak = strategy.position_size < 0 and not bool_waitShortExitBySqueeze and color_bcolor == color.maroon and color_bcolor[1] == color.red

// Condition for when the market re-enters a squeeze.
bool bool_squeezeBackIn = bool_sqzOn and not bool_sqzOn[1]

// Exit a long position if the market re-enters a squeeze and we were waiting for this signal.
bool bool_exitLongSqueeze = strategy.position_size > 0 and bool_waitLongExitBySqueeze and bool_squeezeBackIn

// Exit a short position if the market re-enters a squeeze and we were waiting for this signal.
bool bool_exitShortSqueeze = strategy.position_size < 0 and bool_waitShortExitBySqueeze and bool_squeezeBackIn

// Combine exit conditions for clarity.
bool bool_longExitCondition = bool_exitLongWeak or bool_exitLongSqueeze
bool bool_shortExitCondition = bool_exitShortWeak or bool_exitShortSqueeze

// Reset state on exit to be ready for the next trade.
if (bool_longExitCondition or bool_shortExitCondition)
    bool_waitLongExitBySqueeze := false
    bool_waitShortExitBySqueeze := false


// === Trade Execution ===

// --- Entry Logic ---
if (bool_longSignalFiltered)
    strategy.entry("Long", strategy.long)

if (bool_shortSignalFiltered)
    strategy.entry("Short", strategy.short)

// --- Exit Logic ---
if (bool_longExitCondition)
    strategy.close("Long", comment="Exit Long")

if (bool_shortExitCondition)
    strategy.close("Short", comment="Exit Short")

// --- Stop Loss Logic ---
if (bool_useStopLoss)
    if (strategy.position_size > 0)
        strategy.exit("SL", "Long", stop=strategy.position_avg_price * (1 - float_stopLossPercent / 100))
    if (strategy.position_size < 0)
        strategy.exit("SL", "Short", stop=strategy.position_avg_price * (1 + float_stopLossPercent / 100))


// === Visualization ===
plotshape(bool_longSignalFiltered, title="Long Entry", location=location.belowbar, color=color.new(color.green, 0), style=shape.triangleup, size=size.small)
plotshape(bool_shortSignalFiltered, title="Short Entry", location=location.abovebar, color=color.new(color.red, 0), style=shape.triangledown, size=size.small)
plotshape(bool_longExitCondition and strategy.position_size > 0, title="Exit Long", location=location.belowbar, color=color.new(color.gray, 0), style=shape.xcross, size=size.tiny)
plotshape(bool_shortExitCondition and strategy.position_size < 0, title="Exit Short", location=location.abovebar, color=color.new(color.gray, 0), style=shape.xcross, size=size.tiny)

// To see the indicator in a separate pane, you can add the original indicator to the chart.
// This strategy script focuses on executing trades based on the logic.

//––– Kelly Stats –––
// This code block calculates and displays Kelly criterion statistics.
// It runs only on the last bar to collect data from all closed trades.

// Function to calculate the sample variance of a float array.
arrayVariance(src) =>
    float float_mean = array.avg(src)
    float float_sumOfSquares = 0.0
    for i = 0 to array.size(src) - 1
        float_sumOfSquares += math.pow(array.get(src, i) - float_mean, 2)
    int int_n = array.size(src)
    float result = int_n > 1 ? float_sumOfSquares / (int_n - 1) : 0.0
    result

// 1. Declare a global array to store the return of each trade.
//    Use the 'var' keyword to ensure the array persists across bars.
var array<float> array_float_tradeReturns = array.new_float()

// 2. Main logic block, executed only on the last historical bar.
if barstate.islast
    // Populate the array from all closed trades.
    if strategy.closedtrades > 0 and array.size(array_float_tradeReturns) == 0
        for i = 0 to strategy.closedtrades - 1
            // Calculate the initial capital of the trade for v5.
            float float_entryVal = strategy.closedtrades.entry_price(i) * strategy.closedtrades.size(i)
            // Avoid division by zero error if capital is not zero.
            if float_entryVal != 0
                // Calculate the percentage return of this trade.
                float float_tradeReturn = (strategy.closedtrades.profit(i) / float_entryVal) * 100
                // Store the return in the global array.
                array.push(array_float_tradeReturns, float_tradeReturn)

    // 3. If there is trade data, calculate Kelly criterion statistics.
    float float_meanReturn = na
    float float_varianceReturn = na
    float float_kellyFraction = na

    if array.size(array_float_tradeReturns) > 0
        // Calculate the average return (average profit percentage per trade).
        float_meanReturn := array.avg(array_float_tradeReturns)
        // Calculate the variance of returns (sample variance) using the custom function.
        float_varianceReturn := arrayVariance(array_float_tradeReturns)
        // Calculate the Kelly fraction, handling the case where variance is zero.
        if float_varianceReturn != 0
            float_kellyFraction := float_meanReturn / float_varianceReturn

    // 4. Display statistics in a table on the chart.
    //    The table is created only once and updated on the last bar.
    var table table_kellyStats = table.new(position.top_left, 2, 4, border_width = 1)
    if barstate.islast
        // Table header
        table.cell(table_kellyStats, 0, 0, "Metric", bgcolor = color.new(color.blue, 75))
        table.cell(table_kellyStats, 1, 0, "Value", bgcolor = color.new(color.blue, 75))
        
        // Average return
        table.cell(table_kellyStats, 0, 1, "Mean Return (%)")
        table.cell(table_kellyStats, 1, 1, str.tostring(float_meanReturn, "0.00"))
        
        // Return variance
        table.cell(table_kellyStats, 0, 2, "Return Variance")
        table.cell(table_kellyStats, 1, 2, str.tostring(float_varianceReturn, "0.00"))

        // Kelly fraction
        table.cell(table_kellyStats, 0, 3, "Kelly Fraction")
        table.cell(table_kellyStats, 1, 3, str.tostring(float_kellyFraction, "0.00"))