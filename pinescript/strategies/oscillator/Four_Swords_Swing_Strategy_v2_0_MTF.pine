// @version=5
strategy("Four Swords Swing Strategy v2.0 MTF", shorttitle="4S v2.0 MTF", overlay=true,
         initial_capital=1000, default_qty_type=strategy.percent_of_equity,
         default_qty_value=20, commission_type=strategy.commission.percent,
         commission_value=0.02, dynamic_requests=true)

// ⌘ SUMMARY:
// Type: strategy (MTF Multi-Timeframe Version)
// Purpose: Implement simplified MTF architecture based on LuxAlgo analysis
// Key Features:
// 1. MTF Weight Scoring: 15m(20%) + 1h(30%) + 4h(50%) timeframe analysis
// 2. Simplified Signal Logic: SQZMOM + WaveTrend core with clean filters
// 3. Modular Architecture: 15-line functions, 3-level nesting max
// 4. Clean State Management: Minimal boolean flags
// Status: v2.0 Production-ready with complexity controls

// === 常量定义 ===
// MTF权重配置
MTF_WEIGHT_15M = 0.2
MTF_WEIGHT_1H = 0.3
MTF_WEIGHT_4H = 0.5

// 信号阈值
MTF_THRESHOLD_TRENDING = 0.6
MTF_THRESHOLD_RANGING = 0.7
VOLUME_THRESHOLD = 1.2

// 状态枚举
SIGNAL_WAITING = 0
SIGNAL_ACTIVE = 1
SIGNAL_EXITING = 2

// === 输入参数 ===
// SQZMOM核心参数
int_bbLength = input.int(20, "BB Length", group="Core Indicators")
float_bbMult = input.float(2.0, "BB Multiplier", group="Core Indicators")
int_kcLength = input.int(20, "KC Length", group="Core Indicators")
float_kcMult = input.float(1.5, "KC Multiplier", group="Core Indicators")

// WaveTrend参数
int_wtLength1 = input.int(10, "WT Channel Length", group="Core Indicators")
int_wtLength2 = input.int(21, "WT Average Length", group="Core Indicators")

// MTF设置
bool_enableMTF = input.bool(true, "Enable MTF Confirmation", group="MTF Settings")
float_mtfThreshold = input.float(0.6, "MTF Threshold", minval=0.3, maxval=0.9, group="MTF Settings")

// 过滤器设置
bool_useEMAFilter = input.bool(true, "Use EMA Trend Filter", group="Filters")
int_emaFast = input.int(20, "EMA Fast", group="Filters")
int_emaSlow = input.int(50, "EMA Slow", group="Filters")
bool_useVolumeFilter = input.bool(true, "Use Volume Filter", group="Filters")

// 交易设置
string_tradeDirection = input.string("Both", "Trade Direction", options=["Long Only", "Short Only", "Both"], group="Trading")

// === UDT数据结构 ===
// @type 信号数据结构
type SignalData
    bool sqzSignal
    float momentum
    bool wtSignal
    float wtStrength
    float mtfScore
    bool mtfConfirmed

// @type 状态管理
type TradeState
    int signalState
    float entryPrice
    int entryBar
    bool waitForSqueeze

// === 核心信号函数 ===
// @function SQZMOM信号检测 (基于v1.7.4验证逻辑)
squeezeMomentum() =>
    float_basis = ta.sma(close, int_bbLength)
    float_dev = float_bbMult * ta.stdev(close, int_bbLength)
    float_upperBB = float_basis + float_dev
    float_lowerBB = float_basis - float_dev
    
    float_ma = ta.sma(close, int_kcLength)
    float_rangema = ta.sma(ta.tr, int_kcLength)
    float_upperKC = float_ma + float_rangema * float_kcMult
    float_lowerKC = float_ma - float_rangema * float_kcMult
    
    bool_sqzOn = (float_lowerBB > float_lowerKC) and (float_upperBB < float_upperKC)
    bool_sqzOff = (float_lowerBB < float_lowerKC) and (float_upperBB > float_upperKC)
    bool_signalBar = bool_sqzOn[1] and not bool_sqzOn
    
    float_momentum = ta.linreg(close - math.avg(math.avg(ta.highest(high, int_kcLength), ta.lowest(low, int_kcLength)), ta.sma(close, int_kcLength)), int_kcLength, 0)
    
    [bool_signalBar, float_momentum]

// @function WaveTrend信号检测 (基于v1.7.4验证逻辑)
waveTrendSignal() =>
    float_ap = hlc3
    float_esa = ta.ema(float_ap, int_wtLength1)
    float_d = ta.ema(math.abs(float_ap - float_esa), int_wtLength1)
    float_ci = float_d != 0 ? (float_ap - float_esa) / (0.015 * float_d) : 0.0
    float_tci = ta.ema(float_ci, int_wtLength2)
    
    float_wt1 = float_tci
    float_wt2 = ta.sma(float_wt1, 4)
    bool_wtUpSignal = float_wt1 > float_wt2
    
    [bool_wtUpSignal, float_wt1]

// === MTF计算 (在全局作用域) ===
// 15分钟趋势强度
float_mtf15m = bool_enableMTF ? request.security(syminfo.tickerid, "15", ta.ema(close, 20) > ta.ema(close, 50) ? 1.0 : 0.0) * MTF_WEIGHT_15M : MTF_WEIGHT_15M

// 1小时趋势强度  
float_mtf1h = bool_enableMTF ? request.security(syminfo.tickerid, "60", ta.ema(close, 20) > ta.ema(close, 50) ? 1.0 : 0.0) * MTF_WEIGHT_1H : MTF_WEIGHT_1H

// 4小时趋势强度
float_mtf4h = bool_enableMTF ? request.security(syminfo.tickerid, "240", ta.ema(close, 20) > ta.ema(close, 50) ? 1.0 : 0.0) * MTF_WEIGHT_4H : MTF_WEIGHT_4H

// MTF总评分
float_mtfTotalScore = float_mtf15m + float_mtf1h + float_mtf4h
bool_mtfConfirmed = bool_enableMTF ? (float_mtfTotalScore >= float_mtfThreshold) : true

// MTF分析函数已不需要 - 直接使用全局变量

// === 过滤器计算 (在全局作用域) ===
// EMA趋势过滤
float_emaFastLine = ta.ema(close, int_emaFast)
float_emaSlowLine = ta.ema(close, int_emaSlow)
bool_emaConfirm = bool_useEMAFilter ? (float_emaFastLine > float_emaSlowLine) : true

// 成交量过滤
float_avgVolume = ta.sma(volume, 20)
bool_volumeConfirm = bool_useVolumeFilter ? (volume > float_avgVolume * VOLUME_THRESHOLD) : true

// @function 过滤器应用 (使用全局计算的值)
applyFilters(bool_signal) => bool_signal and bool_emaConfirm and bool_volumeConfirm

// === 主要计算 ===
// 获取核心信号
[bool_sqzSignal, float_momentum] = squeezeMomentum()
[bool_wtSignal, float_wtStrength] = waveTrendSignal()
// MTF分析结果已在全局作用域计算

// 信号组合逻辑
bool_basicLongSignal = bool_sqzSignal and float_momentum > 0 and bool_wtSignal and bool_mtfConfirmed
bool_basicShortSignal = bool_sqzSignal and float_momentum < 0 and not bool_wtSignal and bool_mtfConfirmed

// 应用过滤器
bool_longSignal = applyFilters(bool_basicLongSignal) and (string_tradeDirection != "Short Only")
bool_shortSignal = applyFilters(bool_basicShortSignal) and (string_tradeDirection != "Long Only")

// === 状态管理 ===
var TradeState tradeState = TradeState.new(SIGNAL_WAITING, na, na, false)

// 入场逻辑
if bool_longSignal and strategy.position_size == 0
    tradeState.signalState := SIGNAL_ACTIVE
    tradeState.entryPrice := close
    tradeState.entryBar := bar_index
    tradeState.waitForSqueeze := float_momentum > float_momentum[1]
    strategy.entry("Long", strategy.long, comment="4S v2.0 Long")

if bool_shortSignal and strategy.position_size == 0
    tradeState.signalState := SIGNAL_ACTIVE
    tradeState.entryPrice := close
    tradeState.entryBar := bar_index
    tradeState.waitForSqueeze := float_momentum < float_momentum[1]
    strategy.entry("Short", strategy.short, comment="4S v2.0 Short")

// 出场逻辑
bool_exitLong = strategy.position_size > 0 and (tradeState.waitForSqueeze ? (bool_sqzSignal and not bool_sqzSignal[1]) : float_momentum < 0)

bool_exitShort = strategy.position_size < 0 and (tradeState.waitForSqueeze ? (bool_sqzSignal and not bool_sqzSignal[1]) : float_momentum > 0)

if bool_exitLong
    strategy.close("Long", comment="Exit Long v2.0")
    tradeState.signalState := SIGNAL_WAITING

if bool_exitShort
    strategy.close("Short", comment="Exit Short v2.0")
    tradeState.signalState := SIGNAL_WAITING

// === 可视化 ===
// 信号标记
plotshape(bool_longSignal, title="Long Entry v2.0", location=location.belowbar, color=color.new(color.lime, 0), style=shape.triangleup, size=size.normal)
plotshape(bool_shortSignal, title="Short Entry v2.0", location=location.abovebar, color=color.new(color.red, 0), style=shape.triangledown, size=size.normal)
plotshape(bool_exitLong, title="Exit Long v2.0", location=location.belowbar, color=color.new(color.gray, 0), style=shape.xcross, size=size.tiny)
plotshape(bool_exitShort, title="Exit Short v2.0", location=location.abovebar, color=color.new(color.gray, 0), style=shape.xcross, size=size.tiny)

// EMA线条 (使用全局计算的值)
plot(bool_useEMAFilter ? float_emaFastLine : na, "EMA Fast", color.new(color.blue, 30), 1)
plot(bool_useEMAFilter ? float_emaSlowLine : na, "EMA Slow", color.new(color.orange, 30), 1)

// === v2.0状态面板 ===
if barstate.islast
    var table table_status = table.new(position.top_right, 3, 8, border_width=1)
    
    // 表头
    table.cell(table_status, 0, 0, "4S v2.0 MTF", bgcolor=color.new(color.blue, 30), text_color=color.white, text_size=size.normal)
    table.cell(table_status, 1, 0, "Value", bgcolor=color.new(color.blue, 30), text_color=color.white)
    table.cell(table_status, 2, 0, "Status", bgcolor=color.new(color.blue, 30), text_color=color.white)
    
    // MTF评分
    table.cell(table_status, 0, 1, "MTF Score", text_color=color.black)
    table.cell(table_status, 1, 1, str.tostring(float_mtfTotalScore, "#.##"), text_color=color.black)
    table.cell(table_status, 2, 1, bool_mtfConfirmed ? "PASS" : "FAIL", 
              bgcolor=bool_mtfConfirmed ? color.new(color.green, 70) : color.new(color.red, 70), text_color=color.white)
    
    // 压缩状态
    table.cell(table_status, 0, 2, "Squeeze", text_color=color.black)
    table.cell(table_status, 1, 2, bool_sqzSignal ? "SIGNAL" : "WAIT", text_color=color.black)
    table.cell(table_status, 2, 2, bool_sqzSignal ? "ACTIVE" : "STANDBY", 
              bgcolor=bool_sqzSignal ? color.new(color.green, 70) : color.new(color.gray, 70), text_color=color.white)
    
    // 动量状态
    table.cell(table_status, 0, 3, "Momentum", text_color=color.black)
    table.cell(table_status, 1, 3, str.tostring(float_momentum, "#.###"), text_color=color.black)
    table.cell(table_status, 2, 3, float_momentum > 0 ? "UP" : "DOWN", 
              bgcolor=float_momentum > 0 ? color.new(color.green, 70) : color.new(color.red, 70), text_color=color.white)
    
    // WaveTrend状态
    table.cell(table_status, 0, 4, "WaveTrend", text_color=color.black)
    table.cell(table_status, 1, 4, str.tostring(float_wtStrength, "#.#"), text_color=color.black)
    table.cell(table_status, 2, 4, bool_wtSignal ? "UP" : "DOWN", 
              bgcolor=bool_wtSignal ? color.new(color.green, 70) : color.new(color.red, 70), text_color=color.white)
    
    // 趋势过滤 (使用全局计算的值)
    table.cell(table_status, 0, 5, "EMA Trend", text_color=color.black)
    table.cell(table_status, 1, 5, bool_useEMAFilter ? (bool_emaConfirm ? "BULL" : "BEAR") : "OFF", text_color=color.black)
    table.cell(table_status, 2, 5, bool_useEMAFilter ? (bool_emaConfirm ? "PASS" : "FAIL") : "OFF", 
              bgcolor=bool_useEMAFilter ? (bool_emaConfirm ? color.new(color.green, 70) : color.new(color.red, 70)) : color.new(color.gray, 70), text_color=color.white)
    
    // 成交量状态 (使用全局计算的值)
    table.cell(table_status, 0, 6, "Volume", text_color=color.black)
    table.cell(table_status, 1, 6, str.tostring(volume/float_avgVolume, "#.##") + "x", text_color=color.black)
    table.cell(table_status, 2, 6, bool_useVolumeFilter ? (bool_volumeConfirm ? "PASS" : "FAIL") : "OFF", 
              bgcolor=bool_useVolumeFilter ? (bool_volumeConfirm ? color.new(color.green, 70) : color.new(color.red, 70)) : color.new(color.gray, 70), text_color=color.white)
    
    // 版本信息
    table.cell(table_status, 0, 7, "Version", text_color=color.black)
    table.cell(table_status, 1, 7, "v2.0 MTF", text_color=color.black)
    table.cell(table_status, 2, 7, "READY", bgcolor=color.new(color.blue, 70), text_color=color.white)

// === 警报条件 ===
alertcondition(bool_longSignal, "Long Signal v2.0", "4S v2.0: MTF Long signal detected!")
alertcondition(bool_shortSignal, "Short Signal v2.0", "4S v2.0: MTF Short signal detected!")
alertcondition(bool_exitLong or bool_exitShort, "Exit Signal v2.0", "4S v2.0: Position exit signal!")