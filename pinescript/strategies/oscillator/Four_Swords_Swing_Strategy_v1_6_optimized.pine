// @version=5
strategy("Four Swords Swing Strategy v1.6 Optimized", shorttitle="4S v1.6 O", overlay=true, initial_capital=500, default_qty_type=strategy.percent_of_equity, default_qty_value=15, commission_type=strategy.commission.percent, commission_value=0.02, calc_on_every_tick=false)

// ⌘ SUMMARY:
// Type: strategy
// Purpose: Optimized swing strategy with improved signal frequency and adaptive filtering
// Key Improvements: Relaxed entry conditions, adaptive scoring, multiple signal modes
// Signal Target: 2-4 signals per month with 60%+ win rate
// Logic: Balanced approach between signal quality and frequency

// === 输入参数 (Optimized for Better Signal Frequency) ===

// --- 信号模式选择 ---
group_mode = "Signal Mode"
string_signalMode = input.string("Balanced", title="Signal Mode", options=["Strict", "Balanced", "Aggressive"], tooltip="Strict: High quality few signals, Balanced: Moderate quality more signals, Aggressive: Lower quality many signals", group=group_mode)

// --- SQZMOM 优化参数 ---
group_sqzmom = "Squeeze Momentum (Optimized)"
int_bbLength = input.int(15, title="BB Length", minval=10, maxval=25, tooltip="Reduced from 20 for more sensitivity", group=group_sqzmom)
float_bbMult = input.float(1.8, title="BB Multiplier", minval=1.5, maxval=2.5, step=0.1, tooltip="Reduced from 2.0 for more squeeze releases", group=group_sqzmom)
int_kcLength = input.int(15, title="KC Length", minval=10, maxval=25, tooltip="Reduced from 20 for faster response", group=group_sqzmom)
float_kcMult = input.float(1.3, title="KC Multiplier", minval=1.0, maxval=2.0, step=0.1, tooltip="Reduced from 1.5 for more frequent signals", group=group_sqzmom)
bool_useTrueRange = input.bool(true, title="Use True Range (KC)", group=group_sqzmom)

// --- WaveTrend 优化参数 ---
group_wavetrend = "WaveTrend Filter (Optimized)"
int_n1 = input.int(10, "WT Channel Length", minval=8, maxval=15, tooltip="Optimized for daily timeframe", group=group_wavetrend)
int_n2 = input.int(18, "WT Average Length", minval=15, maxval=25, tooltip="Reduced from 21 for faster response", group=group_wavetrend)
int_wtSmooth = input.int(3, "WT Smoothing", minval=2, maxval=5, tooltip="Reduced from 4 for more sensitivity", group=group_wavetrend)

// --- 智能过滤系统 ---
group_filters = "Smart Filters"
bool_useAdaptiveFilters = input.bool(true, "Enable Adaptive Filters", tooltip="Automatically adjust filters based on market conditions", group=group_filters)
bool_useEMAFilter = input.bool(false, "Force EMA Trend Filter", tooltip="Force EMA filter even in ranging markets", group=group_filters)
int_emaFast = input.int(20, "EMA Fast", minval=15, maxval=30, group=group_filters)
int_emaSlow = input.int(50, "EMA Slow", minval=40, maxval=60, group=group_filters)
bool_useVolumeFilter = input.bool(false, "Force Volume Filter", tooltip="Force volume filter even in low volume periods", group=group_filters)
float_volumeMultiplier = input.float(1.2, "Volume Multiplier", minval=1.0, maxval=2.0, step=0.1, group=group_filters)

// --- 评分系统优化 ---
group_scoring = "Adaptive Scoring System"
bool_useFlexibleScoring = input.bool(true, "Enable Flexible Scoring", tooltip="Allow near-miss signals with additional validation", group=group_scoring)
float_toleranceRange = input.float(10.0, "Score Tolerance", minval=5.0, maxval=15.0, step=1.0, tooltip="Points tolerance for near-miss signals", group=group_scoring)

// --- 风险管理 ---
group_risk = "Risk Management"
bool_useStopLoss = input.bool(true, "Enable Stop Loss", group=group_risk)
float_atrMultiplier = input.float(2.0, "ATR Stop Multiplier", minval=1.5, maxval=3.0, step=0.1, group=group_risk)
int_atrLength = input.int(14, "ATR Length", minval=10, maxval=20, group=group_risk)
bool_useVolatilityPosition = input.bool(true, "Volatility-Adjusted Sizing", group=group_risk)
float_basePositionSize = input.float(15.0, "Base Position Size %", minval=10.0, maxval=25.0, step=1.0, group=group_risk)
float_maxDrawdownPercent = input.float(15.0, "Max Drawdown %", minval=10.0, maxval=25.0, step=1.0, group=group_risk)
int_maxConsecutiveLosses = input.int(3, "Max Consecutive Losses", minval=2, maxval=5, group=group_risk)
bool_useTimeExit = input.bool(true, "Enable Time-Based Exit", group=group_risk)
int_maxBarsInTrade = input.int(30, "Max Bars in Trade", minval=20, maxval=60, tooltip="Reduced from 50 for more active management", group=group_risk)

// --- 策略设置 ---
group_strategy = "Strategy Settings"
string_tradeDirection = input.string("Both", title="Trade Direction", options=["Long Only", "Short Only", "Both"], group=group_strategy)
bool_useConfirmedSignal = input.bool(false, title="Use Delayed Confirmed Signal", tooltip="Wait 1 bar to confirm signal", group=group_strategy)

// === 核心计算 ===

// --- Market Regime Detection ---
float_atr14 = ta.atr(14)
float_atr50sma = ta.sma(float_atr14, 50)
float_atrRatio = float_atr14 / float_atr50sma
float_emaFastLine = ta.ema(close, 20)
float_emaSlowLine = ta.ema(close, 50)
float_trendStrength = math.abs(float_emaFastLine - float_emaSlowLine) / float_atr14
bool_trendingMarket = float_trendStrength > 1.5  // Reduced from 2.0 for more sensitivity
bool_volatileMarket = float_atrRatio > 1.15      // Reduced from 1.2 for more sensitivity

// --- SQZMOM 计算 (Optimized Parameters) ---
float_source = close
float_basis = ta.sma(float_source, int_bbLength)
float_dev = float_bbMult * ta.stdev(float_source, int_bbLength)
float_upperBB = float_basis + float_dev
float_lowerBB = float_basis - float_dev

float_ma = ta.sma(float_source, int_kcLength)
float_kcRange = bool_useTrueRange ? ta.tr : (high - low)
float_rangema = ta.sma(float_kcRange, int_kcLength)
float_upperKC = float_ma + float_rangema * float_kcMult
float_lowerKC = float_ma - float_rangema * float_kcMult

bool_sqzOn = (float_lowerBB > float_lowerKC) and (float_upperBB < float_upperKC)
bool_sqzOff = (float_lowerBB < float_lowerKC) and (float_upperBB > float_upperKC)
bool_noSqz = not bool_sqzOn and not bool_sqzOff

// Momentum计算 (LazyBear方法)
float_momentum = ta.linreg(float_source - math.avg(math.avg(ta.highest(high, int_kcLength), ta.lowest(low, int_kcLength)), ta.sma(close, int_kcLength)), int_kcLength, 0)

// --- Enhanced Momentum Detection ---
float_momentumSMA3 = ta.sma(float_momentum, 3)
float_momentumRate = float_momentum != 0 ? (float_momentum - float_momentum[1]) / math.max(math.abs(float_momentum[1]), 0.001) : 0
bool_momentumAccelerating = (float_momentum > float_momentumSMA3 and float_momentumRate > 0.03)  // Reduced threshold from 0.05

// --- WaveTrend 计算 (Optimized) ---
float_ap = hlc3
float_esa = ta.ema(float_ap, int_n1)
float_d = ta.ema(math.abs(float_ap - float_esa), int_n1)
// Division by zero protection
float_ci = float_d != 0 ? (float_ap - float_esa) / (0.015 * float_d) : 0
float_tci = ta.ema(float_ci, int_n2)

float_wt1 = float_tci
float_wt2 = ta.sma(float_wt1, int_wtSmooth)  // Reduced smoothing

// --- 风险管理计算 ---
float_atrValue = ta.atr(int_atrLength)

// 波动率调整仓位计算
float_volatility = ta.stdev(close, 20) / ta.sma(close, 20)
float_normalizedVol = float_volatility / ta.sma(float_volatility, 50)
float_positionSize = bool_useVolatilityPosition ? math.max(10.0, math.min(20.0, float_basePositionSize / math.max(float_normalizedVol, 0.8))) : float_basePositionSize

// 回撤和连续亏损跟踪
var float float_peakEquity = strategy.initial_capital
var int int_consecutiveLosses = 0
var int int_barsInTrade = 0

if (strategy.equity > float_peakEquity)
    float_peakEquity := strategy.equity

float_currentDrawdown = (float_peakEquity - strategy.equity) / float_peakEquity * 100

// 连续亏损计数
if (strategy.closedtrades > 0 and strategy.closedtrades.exit_time(strategy.closedtrades - 1) == time)
    if (strategy.closedtrades.profit(strategy.closedtrades - 1) < 0)
        int_consecutiveLosses += 1
    else
        int_consecutiveLosses := 0

// 当前交易持续时间
if (strategy.position_size != 0)
    int_barsInTrade += 1
else
    int_barsInTrade := 0

// 风险保护条件
bool_drawdownBreached = float_currentDrawdown >= float_maxDrawdownPercent
bool_maxLossesReached = int_consecutiveLosses >= int_maxConsecutiveLosses
bool_timeExitNeeded = bool_useTimeExit and int_barsInTrade >= int_maxBarsInTrade
bool_circuitBreaker = bool_drawdownBreached or bool_maxLossesReached

// --- 智能过滤系统 ---

// EMA趋势过滤 (Adaptive)
float_emaFastLineFilter = ta.ema(close, int_emaFast)
float_emaSlowLineFilter = ta.ema(close, int_emaSlow)
bool_emaFilterActive = bool_useEMAFilter or (bool_useAdaptiveFilters and bool_trendingMarket)
bool_emaBullTrend = bool_emaFilterActive ? (float_emaFastLineFilter > float_emaSlowLineFilter) : true
bool_emaBearTrend = bool_emaFilterActive ? (float_emaFastLineFilter < float_emaSlowLineFilter) : true

// 成交量过滤 (Adaptive)
float_avgVolume = ta.sma(volume, 20)
bool_volumeFilterActive = bool_useVolumeFilter or (bool_useAdaptiveFilters and not bool_volatileMarket)
bool_volumeConfirm = bool_volumeFilterActive ? (volume > float_avgVolume * float_volumeMultiplier) : true

// === 优化信号逻辑 ===

// --- 基础SQZMOM信号 ---
bool_blackCross_raw = bool_sqzOn[1] and not bool_sqzOn
bool_signalBar_raw = bool_blackCross_raw and not bool_noSqz

bool_blackCross = bool_useConfirmedSignal ? bool_blackCross_raw[1] : bool_blackCross_raw
bool_signalBar = bool_useConfirmedSignal ? bool_signalBar_raw[1] : bool_signalBar_raw

// --- 多模式信号生成 ---

// 基础信号 (v1.4 Compatible)
bool_basicLongSignal = bool_signalBar and float_momentum > 0 and float_wt1 > float_wt2
bool_basicShortSignal = bool_signalBar and float_momentum < 0 and float_wt1 < float_wt2

// 优化的评分系统
float_confirmationScore = 0.0
if (bool_signalBar)
    float_confirmationScore += 30.0  // SQZMOM信号
if (float_momentum > 0)
    float_confirmationScore += 25.0  // 动量方向
if (float_wt1 > float_wt2)
    float_confirmationScore += 15.0  // WaveTrend (reduced from 20)
if (bool_emaBullTrend)
    float_confirmationScore += 15.0  // EMA趋势
if (bool_volumeConfirm)
    float_confirmationScore += 15.0  // 成交量 (increased from 10)

// 动态阈值根据信号模式调整
float_requiredScore = 70.0  // Base threshold
if (string_signalMode == "Strict")
    float_requiredScore := bool_volatileMarket ? 85.0 : 80.0
else if (string_signalMode == "Balanced")
    float_requiredScore := bool_volatileMarket ? 75.0 : 65.0
else if (string_signalMode == "Aggressive")
    float_requiredScore := bool_volatileMarket ? 70.0 : 55.0

// 高质量信号
bool_highQualityLongSignal = float_confirmationScore >= float_requiredScore and float_momentum > 0
bool_highQualityShortSignal = float_confirmationScore >= float_requiredScore and float_momentum < 0

// 近似信号 (Flexible Scoring)
bool_nearMissLong = false
bool_nearMissShort = false

if (bool_useFlexibleScoring)
    float_toleranceScore = float_requiredScore - float_toleranceRange
    bool_nearMissLong := (float_confirmationScore >= float_toleranceScore) and (float_confirmationScore < float_requiredScore) and bool_signalBar and float_momentum > 0
    bool_nearMissShort := (float_confirmationScore >= float_toleranceScore) and (float_confirmationScore < float_requiredScore) and bool_signalBar and float_momentum < 0
    
    // 近似信号的额外验证
    bool_momentumStrengthOK = math.abs(float_momentum) > math.abs(float_momentum[1]) * 1.05
    bool_volumeSpikeOK = volume > float_avgVolume * 1.3
    
    bool_nearMissLong := bool_nearMissLong and bool_momentumStrengthOK and (bool_volumeSpikeOK or not bool_volumeFilterActive)
    bool_nearMissShort := bool_nearMissShort and bool_momentumStrengthOK and (bool_volumeSpikeOK or not bool_volumeFilterActive)

// --- 最终信号合成 ---
bool_swingLongSignal = bool_highQualityLongSignal or bool_nearMissLong
bool_swingShortSignal = bool_highQualityShortSignal or bool_nearMissShort

// --- 最终过滤信号 ---
bool_longSignalFiltered = (string_tradeDirection != "Short Only") and bool_swingLongSignal and not bool_circuitBreaker
bool_shortSignalFiltered = (string_tradeDirection != "Long Only") and bool_swingShortSignal and not bool_circuitBreaker

// --- Enhanced State Management ---
var bool bool_waitLongExitBySqueeze = false
var bool bool_waitShortExitBySqueeze = false
var float float_longStopPrice = na
var float float_shortStopPrice = na
var float float_entryPrice = na

// 决定退出条件类型
if (bool_longSignalFiltered and strategy.position_size == 0)
    bool_waitLongExitBySqueeze := bool_momentumAccelerating and (float_momentum > 0)
    float_entryPrice := close
    float_longStopPrice := bool_useStopLoss ? close - (float_atrValue * float_atrMultiplier) : na

if (bool_shortSignalFiltered and strategy.position_size == 0)
    bool_waitShortExitBySqueeze := bool_momentumAccelerating and (float_momentum < 0)
    float_entryPrice := close
    float_shortStopPrice := bool_useStopLoss ? close + (float_atrValue * float_atrMultiplier) : na

// --- Enhanced Exit Logic ---
// 动量减弱退出
bool_exitLongWeak = strategy.position_size > 0 and not bool_waitLongExitBySqueeze and (float_momentum < 0)
bool_exitShortWeak = strategy.position_size < 0 and not bool_waitShortExitBySqueeze and (float_momentum > 0)

// 新压缩退出
bool_squeezeBackIn = bool_sqzOn and not bool_sqzOn[1]
bool_exitLongSqueeze = strategy.position_size > 0 and bool_waitLongExitBySqueeze and bool_squeezeBackIn
bool_exitShortSqueeze = strategy.position_size < 0 and bool_waitShortExitBySqueeze and bool_squeezeBackIn

// 止损退出
bool_longStopHit = bool_useStopLoss and strategy.position_size > 0 and not na(float_longStopPrice) and close <= float_longStopPrice
bool_shortStopHit = bool_useStopLoss and strategy.position_size < 0 and not na(float_shortStopPrice) and close >= float_shortStopPrice

// 合并退出条件
bool_longExitCondition = bool_exitLongWeak or bool_exitLongSqueeze or bool_longStopHit or bool_timeExitNeeded
bool_shortExitCondition = bool_exitShortWeak or bool_exitShortSqueeze or bool_shortStopHit or bool_timeExitNeeded

// 重置状态
if (bool_longExitCondition or bool_shortExitCondition)
    bool_waitLongExitBySqueeze := false
    bool_waitShortExitBySqueeze := false
    float_longStopPrice := na
    float_shortStopPrice := na
    float_entryPrice := na

// === 交易执行 ===

// --- 入场逻辑 ---
if (bool_longSignalFiltered)
    strategy.entry("Long", strategy.long, qty=float_positionSize, comment="4S Long O")

if (bool_shortSignalFiltered)
    strategy.entry("Short", strategy.short, qty=float_positionSize, comment="4S Short O")

// --- 出场逻辑 ---
if (bool_longExitCondition)
    string_exitComment = bool_longStopHit ? "Stop Loss" : bool_timeExitNeeded ? "Time Exit" : "Signal Exit"
    strategy.close("Long", comment=string_exitComment)

if (bool_shortExitCondition)
    string_exitComment = bool_shortStopHit ? "Stop Loss" : bool_timeExitNeeded ? "Time Exit" : "Signal Exit"
    strategy.close("Short", comment=string_exitComment)

// === 可视化 ===

// 信号标记 (Different colors for signal types)
plotshape(bool_highQualityLongSignal, title="High Quality Long", location=location.belowbar, color=color.new(color.green, 0), style=shape.triangleup, size=size.normal)
plotshape(bool_nearMissLong, title="Near Miss Long", location=location.belowbar, color=color.new(color.lime, 0), style=shape.triangleup, size=size.small)
plotshape(bool_highQualityShortSignal, title="High Quality Short", location=location.abovebar, color=color.new(color.red, 0), style=shape.triangledown, size=size.normal)
plotshape(bool_nearMissShort, title="Near Miss Short", location=location.abovebar, color=color.new(color.maroon, 0), style=shape.triangledown, size=size.small)
plotshape(bool_longExitCondition and strategy.position_size > 0, title="Exit Long", location=location.belowbar, color=color.new(color.gray, 0), style=shape.xcross, size=size.tiny)
plotshape(bool_shortExitCondition and strategy.position_size < 0, title="Exit Short", location=location.abovebar, color=color.new(color.gray, 0), style=shape.xcross, size=size.tiny)

// EMA线条 (Conditional)
plot(bool_emaFilterActive ? float_emaFastLineFilter : na, "EMA Fast", color.new(color.blue, 30), 1)
plot(bool_emaFilterActive ? float_emaSlowLineFilter : na, "EMA Slow", color.new(color.orange, 30), 1)

// 止损线
plot(strategy.position_size > 0 and not na(float_longStopPrice) ? float_longStopPrice : na, "Long Stop", color.red, 1, plot.style_stepline)
plot(strategy.position_size < 0 and not na(float_shortStopPrice) ? float_shortStopPrice : na, "Short Stop", color.red, 1, plot.style_stepline)

// === Enhanced Status Panel ===
if barstate.islast
    var table table_status = table.new(position.top_right, 2, 12, border_width=1)
    
    // 表头
    table.cell(table_status, 0, 0, "4S v1.6 Optimized", bgcolor=color.new(color.purple, 10), text_color=color.white, text_size=size.normal)
    table.cell(table_status, 1, 0, "Value", bgcolor=color.new(color.purple, 10), text_color=color.white)
    
    // 信号模式
    table.cell(table_status, 0, 1, "Signal Mode", text_color=color.black)
    table.cell(table_status, 1, 1, string_signalMode, bgcolor=color.new(color.blue, 70), text_color=color.white)
    
    // 压缩状态
    string_sqzStatus = bool_sqzOn ? "ON" : bool_sqzOff ? "OFF" : "NO"
    table.cell(table_status, 0, 2, "Squeeze", text_color=color.black)
    table.cell(table_status, 1, 2, string_sqzStatus, bgcolor=bool_sqzOn ? color.new(color.red, 70) : bool_sqzOff ? color.new(color.green, 70) : color.new(color.gray, 70))
    
    // 动量状态
    table.cell(table_status, 0, 3, "Momentum", text_color=color.black)  
    table.cell(table_status, 1, 3, str.tostring(float_momentum, "#.###"), 
              bgcolor=float_momentum > 0 ? color.new(color.green, 70) : color.new(color.red, 70),
              text_color=color.white)
    
    // WaveTrend状态
    table.cell(table_status, 0, 4, "WaveTrend", text_color=color.black)
    table.cell(table_status, 1, 4, float_wt1 > float_wt2 ? "UP" : "DOWN",
              bgcolor=float_wt1 > float_wt2 ? color.new(color.green, 70) : color.new(color.red, 70),
              text_color=color.white)
    
    // 过滤器状态
    table.cell(table_status, 0, 5, "Active Filters", text_color=color.black)
    string_filterStatus = ""
    if bool_emaFilterActive
        string_filterStatus += "EMA "
    if bool_volumeFilterActive
        string_filterStatus += "VOL "
    if string_filterStatus == ""
        string_filterStatus := "NONE"
    table.cell(table_status, 1, 5, string_filterStatus, text_color=color.black)
    
    // 信号质量评分
    table.cell(table_status, 0, 6, "Signal Score", text_color=color.black)
    table.cell(table_status, 1, 6, str.tostring(float_confirmationScore, "#") + "/" + str.tostring(float_requiredScore, "#"),
              bgcolor=float_confirmationScore >= float_requiredScore ? color.new(color.green, 70) : 
                     (float_confirmationScore >= (float_requiredScore - float_toleranceRange)) ? color.new(color.orange, 70) : color.new(color.red, 70),
              text_color=color.white)
    
    // 市场状态
    table.cell(table_status, 0, 7, "Market Regime", text_color=color.black)
    string_marketRegime = bool_trendingMarket ? (bool_volatileMarket ? "TREND-VOL" : "TRENDING") : (bool_volatileMarket ? "RANGE-VOL" : "RANGING")
    table.cell(table_status, 1, 7, string_marketRegime,
              bgcolor=bool_trendingMarket ? color.new(color.blue, 70) : color.new(color.purple, 70),
              text_color=color.white)
    
    // 风险指标
    table.cell(table_status, 0, 8, "Drawdown", text_color=color.black)
    table.cell(table_status, 1, 8, str.tostring(float_currentDrawdown, "#.#") + "%",
              bgcolor=float_currentDrawdown > 10 ? color.new(color.red, 70) : color.new(color.green, 70),
              text_color=color.white)
    
    // 仓位大小
    table.cell(table_status, 0, 9, "Position Size", text_color=color.black)
    table.cell(table_status, 1, 9, str.tostring(float_positionSize, "#.#") + "%", text_color=color.black)
    
    // 连续亏损
    table.cell(table_status, 0, 10, "Consec. Losses", text_color=color.black)
    table.cell(table_status, 1, 10, str.tostring(int_consecutiveLosses),
              bgcolor=int_consecutiveLosses >= 2 ? color.new(color.orange, 70) : color.new(color.green, 70),
              text_color=color.white)
    
    // 持仓时间
    table.cell(table_status, 0, 11, "Bars in Trade", text_color=color.black)
    table.cell(table_status, 1, 11, str.tostring(int_barsInTrade),
              bgcolor=int_barsInTrade > (int_maxBarsInTrade * 0.8) ? color.new(color.orange, 70) : color.new(color.green, 70),
              text_color=color.white)

// === Enhanced Alert Conditions ===
alertcondition(bool_highQualityLongSignal, "High Quality Long", "4S v1.6O: High quality long signal!")
alertcondition(bool_highQualityShortSignal, "High Quality Short", "4S v1.6O: High quality short signal!")
alertcondition(bool_nearMissLong, "Near Miss Long", "4S v1.6O: Near miss long signal with validation!")
alertcondition(bool_nearMissShort, "Near Miss Short", "4S v1.6O: Near miss short signal with validation!")
alertcondition(bool_longExitCondition or bool_shortExitCondition, "Exit Signal", "4S v1.6O: Position exit signal!")
alertcondition(bool_circuitBreaker, "Circuit Breaker", "4S v1.6O: EMERGENCY - Trading halted!")