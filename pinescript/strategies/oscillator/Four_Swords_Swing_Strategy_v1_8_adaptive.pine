// @version=5
strategy("Four Swords Swing Strategy v1.8 Adaptive Intelligence", shorttitle="4S v1.8 AI", overlay=true,
         initial_capital=1000, default_qty_type=strategy.percent_of_equity,
         default_qty_value=20, commission_type=strategy.commission.percent,
         commission_value=0.02)

// ⌘ SUMMARY:
// Type: strategy (Adaptive Intelligence Version)
// Purpose: Implement advanced v1.8 design with adaptive parameters and risk management
// Key Features:
// 1. Adaptive Parameters: BB/KC parameters adjust to market volatility
// 2. Multi-Timeframe Confirmation: Higher timeframe trend validation
// 3. Signal Quality Scoring: 100-point system to evaluate signal strength
// 4. Dynamic Risk Management: ATR-based stop loss and position sizing
// 5. Market State Awareness: Trending vs ranging market adaptation
// Status: Production-ready adaptive intelligence system

// === 输入参数 ===

// --- SQZMOM 核心参数 ---
int_bbLength = input.int(20, title="BB Length", group="Squeeze Momentum")
float_bbMult = input.float(2.0, title="BB Multiplier", group="Squeeze Momentum")
int_kcLength = input.int(20, title="KC Length", group="Squeeze Momentum")
float_kcMult = input.float(1.5, title="KC Multiplier", group="Squeeze Momentum")
bool_useTrueRange = input.bool(true, title="Use True Range (KC)", group="Squeeze Momentum")

// --- WaveTrend 参数 ---
int_n1 = input.int(10, "WT Channel Length", group="WaveTrend Filter")
int_n2 = input.int(21, "WT Average Length", group="WaveTrend Filter")

// --- 波段增强过滤器 ---
bool_useEMAFilter = input.bool(true, "Use EMA Trend Filter", group="Swing Filters")
int_emaFast = input.int(20, "EMA Fast", group="Swing Filters")
int_emaSlow = input.int(50, "EMA Slow", group="Swing Filters")
bool_useVolumeFilter = input.bool(true, "Use Volume Filter", group="Swing Filters")
float_volumeMultiplier = input.float(1.1, "Volume Multiplier", step=0.1, group="Swing Filters")

// --- v1.8 智能功能开关 ---
string_htfOptions = input.string("4H", "Higher Timeframe", options=["1H", "2H", "4H", "6H", "12H", "1D"], group="v1.8 Adaptive Intelligence")
bool_useAdaptiveParams = input.bool(true, "Use Adaptive Parameters", group="v1.8 Adaptive Intelligence")
bool_useMultiTimeframe = input.bool(true, "Use Multi-Timeframe Confirmation", group="v1.8 Adaptive Intelligence")
bool_useSignalScoring = input.bool(true, "Use Signal Quality Scoring", group="v1.8 Adaptive Intelligence")
bool_useDynamicRisk = input.bool(true, "Use Dynamic Risk Management", group="v1.8 Adaptive Intelligence")

// 时间框架转换函数
string_htf = string_htfOptions == "1H" ? "60" : 
             string_htfOptions == "2H" ? "120" : 
             string_htfOptions == "4H" ? "240" : 
             string_htfOptions == "6H" ? "360" : 
             string_htfOptions == "12H" ? "720" : 
             string_htfOptions == "1D" ? "1D" : "240"

// --- 信号质量评分参数 ---
float_qualityThresholdTrend = input.float(75.0, "Quality Threshold (Trending)", minval=50.0, maxval=100.0, group="Signal Quality")
float_qualityThresholdRange = input.float(85.0, "Quality Threshold (Ranging)", minval=50.0, maxval=100.0, group="Signal Quality")

// --- 动态风险管理参数 ---
float_atrMultiplier = input.float(2.0, "ATR Stop Loss Multiplier", minval=1.0, maxval=5.0, group="Dynamic Risk")
float_maxPositionSize = input.float(25.0, "Max Position Size %", minval=5.0, maxval=50.0, group="Dynamic Risk")
int_maxConsecutiveLosses = input.int(3, "Max Consecutive Losses", minval=1, maxval=10, group="Dynamic Risk")

// --- 策略设置 ---
string_tradeDirection = input.string("Both", title="Trade Direction", options=["Long Only", "Short Only", "Both"], group="Strategy Settings")
bool_useConfirmedSignal = input.bool(false, title="Use Delayed Confirmed Signal", tooltip="Wait 1 bar to confirm signal", group="Strategy Settings")

// === v1.8 自适应核心计算 ===

// --- 波动率自适应系统 (修复NaN问题) ---
float_atr14 = ta.atr(14)
float_atr50 = ta.atr(50)

// 安全的波动率倍数计算，防止除零和NaN
float_volatilityMultiplier = 1.0
if bool_useAdaptiveParams and not na(float_atr14) and not na(float_atr50) and float_atr50 > 0
    float_volatilityMultiplier := math.max(0.5, math.min(3.0, float_atr14 / float_atr50))

// 安全的自适应参数计算
int_adaptiveBBLength = int_bbLength
float_adaptiveBBMult = float_bbMult
int_adaptiveKCLength = int_kcLength
float_adaptiveKCMult = float_kcMult

if bool_useAdaptiveParams and not na(float_volatilityMultiplier)
    int_adaptiveBBLength := math.max(5, math.min(200, math.round(int_bbLength * (1 + (float_volatilityMultiplier - 1) * 0.3))))
    float_adaptiveBBMult := math.max(0.5, math.min(5.0, float_bbMult * (0.8 + 0.4 * float_volatilityMultiplier)))
    int_adaptiveKCLength := math.max(5, math.min(200, math.round(int_kcLength * (1 + (float_volatilityMultiplier - 1) * 0.2))))
    float_adaptiveKCMult := math.max(0.5, math.min(5.0, float_kcMult * (0.8 + 0.4 * float_volatilityMultiplier)))

// --- 市场状态检测 (防止NaN) ---
float_trendStrength = 0.0
if not na(float_atr14) and float_atr14 > 0
    float_trendStrength := math.abs(ta.ema(close, 20) - ta.ema(close, 50)) / float_atr14

bool_trendingMarket = float_trendStrength > 2.0
bool_rangingMarket = not na(float_atr14) and float_atr14 / close < 0.015

// 状态自适应参数 - 修复series vs simple类型冲突
float_adaptiveVolumeThreshold = bool_useAdaptiveParams ? (bool_trendingMarket ? 1.2 : float_volumeMultiplier) : float_volumeMultiplier

// === 核心技术指标计算 ===

// --- SQZMOM 计算 (使用自适应参数) ---
float_source = close
float_basis = ta.sma(float_source, int_adaptiveBBLength)
float_dev = float_adaptiveBBMult * ta.stdev(float_source, int_adaptiveBBLength)
float_upperBB = float_basis + float_dev
float_lowerBB = float_basis - float_dev

float_ma = ta.sma(float_source, int_adaptiveKCLength)
float_kcRange = bool_useTrueRange ? ta.tr : (high - low)
float_rangema = ta.sma(float_kcRange, int_adaptiveKCLength)
float_upperKC = float_ma + float_rangema * float_adaptiveKCMult
float_lowerKC = float_ma - float_rangema * float_adaptiveKCMult

bool_sqzOn = (float_lowerBB > float_lowerKC) and (float_upperBB < float_upperKC)
bool_sqzOff = (float_lowerBB < float_lowerKC) and (float_upperBB > float_upperKC)
bool_noSqz = not bool_sqzOn and not bool_sqzOff

// Momentum计算 (LazyBear方法)
float_momentum = ta.linreg(float_source - math.avg(math.avg(ta.highest(high, int_adaptiveKCLength), ta.lowest(low, int_adaptiveKCLength)), ta.sma(close, int_adaptiveKCLength)), int_adaptiveKCLength, 0)

// --- WaveTrend 计算 (修复series vs simple类型冲突，添加除零保护) ---
// 计算三种不同的WaveTrend，然后选择
float_ap = hlc3
float_esa_trending = ta.ema(float_ap, 8)
float_d_trending = ta.ema(math.abs(float_ap - float_esa_trending), 8)
float_ci_trending = float_d_trending != 0 ? (float_ap - float_esa_trending) / (0.015 * float_d_trending) : 0.0

float_esa_ranging = ta.ema(float_ap, 15)
float_d_ranging = ta.ema(math.abs(float_ap - float_esa_ranging), 15)
float_ci_ranging = float_d_ranging != 0 ? (float_ap - float_esa_ranging) / (0.015 * float_d_ranging) : 0.0

float_esa_normal = ta.ema(float_ap, int_n1)
float_d_normal = ta.ema(math.abs(float_ap - float_esa_normal), int_n1)
float_ci_normal = float_d_normal != 0 ? (float_ap - float_esa_normal) / (0.015 * float_d_normal) : 0.0

// 根据市场状态选择适当的WaveTrend
float_ci = bool_useAdaptiveParams ? (bool_trendingMarket ? float_ci_trending : (bool_rangingMarket ? float_ci_ranging : float_ci_normal)) : float_ci_normal
float_tci = ta.ema(float_ci, int_n2)

float_wt1 = float_tci
float_wt2 = ta.sma(float_wt1, 4)

// --- 波段增强过滤器 ---
float_emaFastLine = ta.ema(close, int_emaFast)
float_emaSlowLine = ta.ema(close, int_emaSlow)
bool_emaBullTrend = bool_useEMAFilter ? (float_emaFastLine > float_emaSlowLine) : true
bool_emaBearTrend = bool_useEMAFilter ? (float_emaFastLine < float_emaSlowLine) : true

// 成交量过滤 (使用自适应阈值)
float_avgVolume = ta.sma(volume, 20)
bool_volumeConfirm = bool_useVolumeFilter ? (volume > float_avgVolume * float_adaptiveVolumeThreshold) : true

// === v1.8 多时间框架确认 ===
float_htfTrendConfirm = bool_useMultiTimeframe ? request.security(syminfo.tickerid, string_htf, ta.ema(close, 20) > ta.ema(close, 50) ? 1.0 : 0.0) : 1.0
bool_htfBullTrend = float_htfTrendConfirm > 0.5
bool_htfBearTrend = float_htfTrendConfirm < 0.5

// === v1.8 信号质量评分系统 ===
float_signalQualityLong = 0.0
float_signalQualityShort = 0.0

if bool_useSignalScoring
    // Long信号质量评分
    if (bool_sqzOff and float_momentum > 0)
        float_signalQualityLong += 25.0  // SQZMOM基础分
    
    if (float_wt1 > float_wt2 and float_wt1 < -20)
        float_signalQualityLong += 20.0  // WaveTrend超卖确认
    
    if (bool_emaBullTrend)
        float_signalQualityLong += 15.0  // 趋势确认
    
    if (bool_volumeConfirm)
        float_signalQualityLong += 15.0  // 成交量确认
    
    if (bool_htfBullTrend)
        float_signalQualityLong += 25.0  // 高时间框架确认
    
    // Short信号质量评分
    if (bool_sqzOff and float_momentum < 0)
        float_signalQualityShort += 25.0  // SQZMOM基础分
    
    if (float_wt1 < float_wt2 and float_wt1 > 20)
        float_signalQualityShort += 20.0  // WaveTrend超买确认
    
    if (bool_emaBearTrend)
        float_signalQualityShort += 15.0  // 趋势确认
    
    if (bool_volumeConfirm)
        float_signalQualityShort += 15.0  // 成交量确认
    
    if (bool_htfBearTrend)
        float_signalQualityShort += 25.0  // 高时间框架确认

// 动态质量阈值
float_qualityThreshold = bool_trendingMarket ? float_qualityThresholdTrend : float_qualityThresholdRange

// === 信号逻辑 ===

// --- 基础SQZMOM信号 ---
bool_blackCross_raw = bool_sqzOn[1] and not bool_sqzOn
bool_signalBar_raw = bool_blackCross_raw

bool_blackCross = bool_useConfirmedSignal ? bool_blackCross_raw[1] : bool_blackCross_raw
bool_signalBar = bool_useConfirmedSignal ? bool_signalBar_raw[1] : bool_signalBar_raw

// --- v1.8 增强信号逻辑 ---
bool_basicLongSignal = bool_signalBar and float_momentum > 0 and float_wt1 > float_wt2
bool_basicShortSignal = bool_signalBar and float_momentum < 0 and float_wt1 < float_wt2

// 质量过滤信号
bool_qualityLongSignal = bool_useSignalScoring ? (bool_basicLongSignal and float_signalQualityLong >= float_qualityThreshold) : bool_basicLongSignal
bool_qualityShortSignal = bool_useSignalScoring ? (bool_basicShortSignal and float_signalQualityShort >= float_qualityThreshold) : bool_basicShortSignal

// 最终过滤信号
bool_longSignalFiltered = (string_tradeDirection != "Short Only") and bool_qualityLongSignal
bool_shortSignalFiltered = (string_tradeDirection != "Long Only") and bool_qualityShortSignal

// === v1.8 动态风险管理 ===

// 连续亏损追踪
var int int_consecutiveLosses = 0
var float float_lastTradeResult = 0.0

// 更新连续亏损计数
if strategy.closedtrades > 0 and strategy.closedtrades != strategy.closedtrades[1]
    float_lastTradeResult := strategy.closedtrades.profit(strategy.closedtrades - 1)
    if float_lastTradeResult < 0
        int_consecutiveLosses += 1
    else
        int_consecutiveLosses := 0

// 风险暂停
bool_riskPause = bool_useDynamicRisk and int_consecutiveLosses >= int_maxConsecutiveLosses

// 动态仓位计算
float_basePosition = 20.0
float_riskAdjustedPosition = bool_useDynamicRisk ? (float_basePosition * (1.0 - (float_volatilityMultiplier - 1.0) * 0.3)) : float_basePosition
float_finalPositionSize = math.min(float_riskAdjustedPosition, float_maxPositionSize)

// --- 状态跟踪 ---
var bool bool_waitLongExitBySqueeze = false
var bool bool_waitShortExitBySqueeze = false
var float float_entryPrice = na
var float float_dynamicStopLoss = na

// 决定退出条件类型
if (bool_longSignalFiltered and strategy.position_size == 0 and not bool_riskPause)
    bool_waitLongExitBySqueeze := (float_momentum > float_momentum[1])
    float_entryPrice := close
    float_dynamicStopLoss := bool_useDynamicRisk ? (close - float_atr14 * float_atrMultiplier) : na

if (bool_shortSignalFiltered and strategy.position_size == 0 and not bool_riskPause)
    bool_waitShortExitBySqueeze := (float_momentum < float_momentum[1])
    float_entryPrice := close
    float_dynamicStopLoss := bool_useDynamicRisk ? (close + float_atr14 * float_atrMultiplier) : na

// --- 退出信号 ---
// 动量减弱退出
bool_exitLongWeak = strategy.position_size > 0 and not bool_waitLongExitBySqueeze and (float_momentum < 0)
bool_exitShortWeak = strategy.position_size < 0 and not bool_waitShortExitBySqueeze and (float_momentum > 0)

// 新压缩退出
bool_squeezeBackIn = bool_sqzOn and not bool_sqzOn[1]
bool_exitLongSqueeze = strategy.position_size > 0 and bool_waitLongExitBySqueeze and bool_squeezeBackIn
bool_exitShortSqueeze = strategy.position_size < 0 and bool_waitShortExitBySqueeze and bool_squeezeBackIn

// 动态止损退出
bool_exitLongStop = bool_useDynamicRisk and strategy.position_size > 0 and not na(float_dynamicStopLoss) and close <= float_dynamicStopLoss
bool_exitShortStop = bool_useDynamicRisk and strategy.position_size < 0 and not na(float_dynamicStopLoss) and close >= float_dynamicStopLoss

// 合并退出条件
bool_longExitCondition = bool_exitLongWeak or bool_exitLongSqueeze or bool_exitLongStop
bool_shortExitCondition = bool_exitShortWeak or bool_exitShortSqueeze or bool_exitShortStop

// 重置状态
if (bool_longExitCondition or bool_shortExitCondition)
    bool_waitLongExitBySqueeze := false
    bool_waitShortExitBySqueeze := false
    float_entryPrice := na
    float_dynamicStopLoss := na

// === 交易执行 ===

// --- 入场逻辑 ---
if (bool_longSignalFiltered and not bool_riskPause)
    strategy.entry("Long", strategy.long, qty=float_finalPositionSize, comment="4S v1.8 Long")

if (bool_shortSignalFiltered and not bool_riskPause)
    strategy.entry("Short", strategy.short, qty=float_finalPositionSize, comment="4S v1.8 Short")

// --- 出场逻辑 ---
if (bool_longExitCondition)
    strategy.close("Long", comment="Exit Long v1.8")

if (bool_shortExitCondition)
    strategy.close("Short", comment="Exit Short v1.8")

// === v1.8 增强可视化 ===

// 信号标记
plotshape(bool_longSignalFiltered and not bool_riskPause, title="Long Entry v1.8", location=location.belowbar, color=color.new(color.lime, 0), style=shape.triangleup, size=size.normal)
plotshape(bool_shortSignalFiltered and not bool_riskPause, title="Short Entry v1.8", location=location.abovebar, color=color.new(color.red, 0), style=shape.triangledown, size=size.normal)
plotshape(bool_longExitCondition and strategy.position_size > 0, title="Exit Long v1.8", location=location.belowbar, color=color.new(color.gray, 0), style=shape.xcross, size=size.tiny)
plotshape(bool_shortExitCondition and strategy.position_size < 0, title="Exit Short v1.8", location=location.abovebar, color=color.new(color.gray, 0), style=shape.xcross, size=size.tiny)

// EMA线条
plot(bool_useEMAFilter ? float_emaFastLine : na, "EMA Fast", color.new(color.blue, 30), 1)
plot(bool_useEMAFilter ? float_emaSlowLine : na, "EMA Slow", color.new(color.orange, 30), 1)

// 动态止损线
plot(bool_useDynamicRisk and not na(float_dynamicStopLoss) ? float_dynamicStopLoss : na, "Dynamic Stop", color.new(color.red, 0), 2, plot.style_cross)

// === v1.8 智能状态面板 ===
if barstate.islast
    var table table_status = table.new(position.top_right, 3, 12, border_width=1)
    
    // 表头
    table.cell(table_status, 0, 0, "4S v1.8 AI", bgcolor=color.new(color.blue, 30), text_color=color.white, text_size=size.normal)
    table.cell(table_status, 1, 0, "Value", bgcolor=color.new(color.blue, 30), text_color=color.white)
    table.cell(table_status, 2, 0, "Status", bgcolor=color.new(color.blue, 30), text_color=color.white)
    
    // 市场状态
    string_marketState = bool_trendingMarket ? "TRENDING" : (bool_rangingMarket ? "RANGING" : "NORMAL")
    table.cell(table_status, 0, 1, "Market State", text_color=color.black)
    table.cell(table_status, 1, 1, string_marketState, text_color=color.black)
    table.cell(table_status, 2, 1, str.tostring(float_trendStrength, "#.##"), bgcolor=bool_trendingMarket ? color.new(color.green, 70) : color.new(color.yellow, 70))
    
    // 波动率倍数
    table.cell(table_status, 0, 2, "Volatility", text_color=color.black)
    table.cell(table_status, 1, 2, str.tostring(float_volatilityMultiplier, "#.##") + "x", text_color=color.black)
    table.cell(table_status, 2, 2, float_volatilityMultiplier > 1.5 ? "HIGH" : (float_volatilityMultiplier < 0.8 ? "LOW" : "NORMAL"), bgcolor=float_volatilityMultiplier > 1.5 ? color.new(color.red, 70) : color.new(color.green, 70))
    
    // 压缩状态
    string_sqzStatus = bool_sqzOn ? "ON" : bool_sqzOff ? "OFF" : "NO"
    table.cell(table_status, 0, 3, "Squeeze", text_color=color.black)
    table.cell(table_status, 1, 3, string_sqzStatus, text_color=color.black)
    table.cell(table_status, 2, 3, "", bgcolor=bool_sqzOn ? color.new(color.red, 70) : bool_sqzOff ? color.new(color.green, 70) : color.new(color.gray, 70))
    
    // 动量状态
    table.cell(table_status, 0, 4, "Momentum", text_color=color.black)
    table.cell(table_status, 1, 4, str.tostring(float_momentum, "#.###"), text_color=color.black)
    table.cell(table_status, 2, 4, float_momentum > 0 ? "UP" : "DOWN", bgcolor=float_momentum > 0 ? color.new(color.green, 70) : color.new(color.red, 70), text_color=color.white)
    
    // WaveTrend状态
    table.cell(table_status, 0, 5, "WaveTrend", text_color=color.black)
    table.cell(table_status, 1, 5, str.tostring(float_wt1, "#.#"), text_color=color.black)
    table.cell(table_status, 2, 5, float_wt1 > float_wt2 ? "UP" : "DOWN", bgcolor=float_wt1 > float_wt2 ? color.new(color.green, 70) : color.new(color.red, 70), text_color=color.white)
    
    // 高时间框架确认
    table.cell(table_status, 0, 6, "HTF Trend", text_color=color.black)
    table.cell(table_status, 1, 6, bool_useMultiTimeframe ? string_htfOptions : "OFF", text_color=color.black)
    table.cell(table_status, 2, 6, bool_useMultiTimeframe ? (bool_htfBullTrend ? "BULL" : "BEAR") : "OFF", bgcolor=bool_useMultiTimeframe ? (bool_htfBullTrend ? color.new(color.green, 70) : color.new(color.red, 70)) : color.new(color.gray, 70), text_color=color.white)
    
    // 信号质量评分
    float_currentQuality = bool_longSignalFiltered ? float_signalQualityLong : (bool_shortSignalFiltered ? float_signalQualityShort : 0.0)
    table.cell(table_status, 0, 7, "Signal Quality", text_color=color.black)
    table.cell(table_status, 1, 7, bool_useSignalScoring ? str.tostring(float_currentQuality, "#") + "/100" : "OFF", text_color=color.black)
    table.cell(table_status, 2, 7, bool_useSignalScoring ? (float_currentQuality >= float_qualityThreshold ? "PASS" : "FAIL") : "OFF", bgcolor=bool_useSignalScoring ? (float_currentQuality >= float_qualityThreshold ? color.new(color.green, 70) : color.new(color.red, 70)) : color.new(color.gray, 70), text_color=color.white)
    
    // 动态仓位
    table.cell(table_status, 0, 8, "Position Size", text_color=color.black)
    table.cell(table_status, 1, 8, str.tostring(float_finalPositionSize, "#.#") + "%", text_color=color.black)
    table.cell(table_status, 2, 8, bool_useDynamicRisk ? "DYNAMIC" : "FIXED", bgcolor=bool_useDynamicRisk ? color.new(color.blue, 70) : color.new(color.gray, 70), text_color=color.white)
    
    // 风险状态
    table.cell(table_status, 0, 9, "Risk Status", text_color=color.black)
    table.cell(table_status, 1, 9, str.tostring(int_consecutiveLosses) + "/" + str.tostring(int_maxConsecutiveLosses), text_color=color.black)
    table.cell(table_status, 2, 9, bool_riskPause ? "PAUSED" : "ACTIVE", bgcolor=bool_riskPause ? color.new(color.red, 70) : color.new(color.green, 70), text_color=color.white)
    
    // 自适应参数状态
    string_adaptiveWT = bool_useAdaptiveParams ? (bool_trendingMarket ? "8" : (bool_rangingMarket ? "15" : str.tostring(int_n1))) : str.tostring(int_n1)
    table.cell(table_status, 0, 10, "Adaptive", text_color=color.black)
    table.cell(table_status, 1, 10, "BB:" + str.tostring(int_adaptiveBBLength) + " WT:" + string_adaptiveWT, text_color=color.black)
    table.cell(table_status, 2, 10, bool_useAdaptiveParams ? "ON" : "OFF", bgcolor=bool_useAdaptiveParams ? color.new(color.green, 70) : color.new(color.gray, 70), text_color=color.white)
    
    // 版本信息
    table.cell(table_status, 0, 11, "Version", text_color=color.black)
    table.cell(table_status, 1, 11, "v1.8 AI", text_color=color.black)
    table.cell(table_status, 2, 11, "READY", bgcolor=color.new(color.blue, 70), text_color=color.white)

// === 警报条件 ===
alertcondition(bool_longSignalFiltered and not bool_riskPause, "Long Signal v1.8", "4S v1.8: High-quality long signal detected!")
alertcondition(bool_shortSignalFiltered and not bool_riskPause, "Short Signal v1.8", "4S v1.8: High-quality short signal detected!")
alertcondition(bool_longExitCondition or bool_shortExitCondition, "Exit Signal v1.8", "4S v1.8: Position exit signal!")
alertcondition(bool_riskPause, "Risk Pause v1.8", "4S v1.8: Risk management pause activated!")