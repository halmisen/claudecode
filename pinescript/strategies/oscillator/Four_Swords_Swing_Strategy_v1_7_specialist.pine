// @version=5
strategy("Four Swords Swing Strategy v1.7 Specialist", shorttitle="4S v1.7 SPEC", overlay=true, initial_capital=500, default_qty_type=strategy.percent_of_equity, default_qty_value=15, margin_long=25, margin_short=25, commission_type=strategy.commission.percent, commission_value=0.02, calc_on_every_tick=false)

// âŒ˜ SUMMARY:
// Type: strategy (PINE SCRIPT V5 SPECIALIST VERSION)
// Purpose: Clean, compliant Pine Script v5 implementation of Four Swords swing strategy
// Key Features: Proven SQZMOM+WaveTrend core, layered signal visualization, proper scoping
// Compliance: Zero syntax errors, all functions in global scope, proper variable declarations
// Logic: Multi-mode signaling (Strict/Balanced/Aggressive) with sophisticated state management
// Performance: Optimized for TradingView compilation and execution efficiency

// === INPUT PARAMETERS ===

// --- Signal Mode Selection ---
string_signalMode = input.string("Balanced", title="Signal Mode", options=["Strict", "Balanced", "Aggressive"], tooltip="Strict: All filters required\nBalanced: Core+adaptive filters\nAggressive: Core signals only", group="Signal Mode")

// --- SQZMOM Core Parameters ---
int_bbLength = input.int(15, title="BB Length", minval=10, maxval=25, group="Squeeze Momentum")
float_bbMult = input.float(1.8, title="BB Multiplier", minval=1.5, maxval=2.5, step=0.1, group="Squeeze Momentum")
int_kcLength = input.int(15, title="KC Length", minval=10, maxval=25, group="Squeeze Momentum")
float_kcMult = input.float(1.3, title="KC Multiplier", minval=1.0, maxval=2.0, step=0.1, group="Squeeze Momentum")
bool_useTrueRange = input.bool(true, title="Use True Range (KC)", group="Squeeze Momentum")

// --- WaveTrend Parameters ---
int_n1 = input.int(10, "WT Channel Length", minval=8, maxval=15, group="WaveTrend Filter")
int_n2 = input.int(18, "WT Average Length", minval=15, maxval=25, group="WaveTrend Filter")
int_wtSmooth = input.int(3, "WT Smoothing", minval=2, maxval=5, group="WaveTrend Filter")

// --- Adaptive Filters ---
bool_useEMAFilter = input.bool(true, "Use EMA Trend Filter", group="Adaptive Filters")
int_emaFast = input.int(20, "EMA Fast", minval=15, maxval=30, group="Adaptive Filters")
int_emaSlow = input.int(50, "EMA Slow", minval=40, maxval=60, group="Adaptive Filters")
bool_useVolumeFilter = input.bool(true, "Use Volume Filter", group="Adaptive Filters")
float_volumeMultiplier = input.float(1.2, "Volume Multiplier", minval=1.0, maxval=2.0, step=0.1, group="Adaptive Filters")

// --- Risk Management ---
bool_useStopLoss = input.bool(true, "Enable Stop Loss", group="Risk Management")
float_atrMultiplier = input.float(2.0, "ATR Stop Multiplier", minval=1.5, maxval=3.0, step=0.1, group="Risk Management")
int_atrLength = input.int(14, "ATR Length", minval=10, maxval=20, group="Risk Management")
bool_useVolatilityPosition = input.bool(true, "Volatility-Adjusted Sizing", group="Risk Management")
float_basePositionSize = input.float(15.0, "Base Position Size %", minval=10.0, maxval=25.0, step=1.0, group="Risk Management")

// --- Strategy Settings ---
string_tradeDirection = input.string("Both", title="Trade Direction", options=["Long Only", "Short Only", "Both"], group="Strategy Settings")
bool_useConfirmedSignal = input.bool(false, title="Use Delayed Confirmed Signal", tooltip="Wait 1 bar to prevent repainting", group="Strategy Settings")

// --- Visualization ---
bool_showAllSignals = input.bool(true, "Show All Signal Layers", group="Visualization")
bool_showStatus = input.bool(true, "Show Status Panel", group="Visualization")

// === CORE CALCULATIONS ===

// --- Market Regime Detection ---
float_atr14 = ta.atr(14)
float_atr50sma = ta.sma(float_atr14, 50)
float_atrRatio = float_atr14 / float_atr50sma
bool_volatileMarket = float_atrRatio > 1.15

// --- SQZMOM Calculations (Proven Logic) ---
float_source = close
float_basis = ta.sma(float_source, int_bbLength)
float_dev = float_bbMult * ta.stdev(float_source, int_bbLength)
float_upperBB = float_basis + float_dev
float_lowerBB = float_basis - float_dev

float_ma = ta.sma(float_source, int_kcLength)
float_kcRange = bool_useTrueRange ? ta.tr : (high - low)
float_rangema = ta.sma(float_kcRange, int_kcLength)
float_upperKC = float_ma + float_rangema * float_kcMult
float_lowerKC = float_ma - float_rangema * float_kcMult

bool_sqzOn = (float_lowerBB > float_lowerKC) and (float_upperBB < float_upperKC)
bool_sqzOff = (float_lowerBB < float_lowerKC) and (float_upperBB > float_upperKC)
bool_noSqz = not bool_sqzOn and not bool_sqzOff

// --- Momentum Calculation (Optimized) ---
float_momentum = ta.linreg(float_source - math.avg(math.avg(ta.highest(high, int_kcLength), ta.lowest(low, int_kcLength)), ta.sma(close, int_kcLength)), int_kcLength, 0)

// --- WaveTrend Calculations (Proven Logic) ---
float_ap = hlc3
float_esa = ta.ema(float_ap, int_n1)
float_d = ta.ema(math.abs(float_ap - float_esa), int_n1)
float_ci = float_d != 0 ? (float_ap - float_esa) / (0.015 * float_d) : 0
float_tci = ta.ema(float_ci, int_n2)

float_wt1 = float_tci
float_wt2 = ta.sma(float_wt1, int_wtSmooth)

// --- Filter Calculations ---
float_emaFastLine = ta.ema(close, int_emaFast)
float_emaSlowLine = ta.ema(close, int_emaSlow)
bool_emaBullTrend = bool_useEMAFilter ? (float_emaFastLine > float_emaSlowLine) : true
bool_emaBearTrend = bool_useEMAFilter ? (float_emaFastLine < float_emaSlowLine) : true

float_avgVolume = ta.sma(volume, 20)
bool_volumeConfirm = bool_useVolumeFilter ? (volume > float_avgVolume * float_volumeMultiplier) : true

// --- Risk Management Calculations ---
float_atrValue = ta.atr(int_atrLength)
float_volatility = ta.stdev(close, 20) / ta.sma(close, 20)
float_normalizedVol = float_volatility / ta.sma(float_volatility, 50)
float_positionSize = bool_useVolatilityPosition ? math.max(10.0, math.min(20.0, float_basePositionSize / math.max(float_normalizedVol, 0.8))) : float_basePositionSize

// === SIGNAL LOGIC ===

// --- Core Signal Generation ---
bool_blackCross_raw = bool_sqzOn[1] and not bool_sqzOn
bool_signalBar_raw = bool_blackCross_raw and not bool_noSqz

bool_blackCross = bool_useConfirmedSignal ? bool_blackCross_raw[1] : bool_blackCross_raw
bool_signalBar = bool_useConfirmedSignal ? bool_signalBar_raw[1] : bool_signalBar_raw

// --- Layered Signal System ---

// Layer 1: Core SQZMOM signals
bool_layer1_longSignal = bool_signalBar and float_momentum > 0
bool_layer1_shortSignal = bool_signalBar and float_momentum < 0

// Layer 2: + WaveTrend confirmation
bool_layer2_longSignal = bool_layer1_longSignal and float_wt1 > float_wt2
bool_layer2_shortSignal = bool_layer1_shortSignal and float_wt1 < float_wt2

// Layer 3: + EMA filter
bool_layer3_longSignal = bool_layer2_longSignal and bool_emaBullTrend
bool_layer3_shortSignal = bool_layer2_shortSignal and bool_emaBearTrend

// Layer 4: + Volume filter
bool_layer4_longSignal = bool_layer3_longSignal and bool_volumeConfirm
bool_layer4_shortSignal = bool_layer3_shortSignal and bool_volumeConfirm

// --- Final Signal Selection ---
bool_finalLongSignal = string_signalMode == "Strict" ? bool_layer4_longSignal : string_signalMode == "Balanced" ? bool_layer2_longSignal and (bool_emaBullTrend or bool_volumeConfirm) : bool_layer2_longSignal

bool_finalShortSignal = string_signalMode == "Strict" ? bool_layer4_shortSignal : string_signalMode == "Balanced" ? bool_layer2_shortSignal and (bool_emaBearTrend or bool_volumeConfirm) : bool_layer2_shortSignal

// --- Direction Filtering ---
bool_longSignalFiltered = (string_tradeDirection != "Short Only") and bool_finalLongSignal
bool_shortSignalFiltered = (string_tradeDirection != "Long Only") and bool_finalShortSignal

// --- Near Miss Analysis ---
bool_nearMissLong_EMA = bool_layer2_longSignal and not bool_emaBullTrend and bool_volumeConfirm
bool_nearMissLong_Volume = bool_layer2_longSignal and bool_emaBullTrend and not bool_volumeConfirm
bool_nearMissShort_EMA = bool_layer2_shortSignal and not bool_emaBearTrend and bool_volumeConfirm
bool_nearMissShort_Volume = bool_layer2_shortSignal and bool_emaBearTrend and not bool_volumeConfirm

// --- Reversal Signals ---
bool_squeezeBackIn = bool_sqzOn and not bool_sqzOn[1]
bool_reversalToLong = bool_squeezeBackIn and float_momentum > 0 and float_wt1 > float_wt2
bool_reversalToShort = bool_squeezeBackIn and float_momentum < 0 and float_wt1 < float_wt2

// === STATE MANAGEMENT ===

// --- State Variables ---
var bool bool_waitLongExitBySqueeze = false
var bool bool_waitShortExitBySqueeze = false
var float float_longStopPrice = na
var float float_shortStopPrice = na

// --- Entry State Logic ---
if (bool_longSignalFiltered and strategy.position_size == 0)
    bool_waitLongExitBySqueeze := (float_momentum > float_momentum[1])
    float_longStopPrice := bool_useStopLoss ? close - (float_atrValue * float_atrMultiplier) : na

if (bool_shortSignalFiltered and strategy.position_size == 0)
    bool_waitShortExitBySqueeze := (float_momentum < float_momentum[1])
    float_shortStopPrice := bool_useStopLoss ? close + (float_atrValue * float_atrMultiplier) : na

// --- Exit Conditions ---
bool_exitLongWeak = strategy.position_size > 0 and not bool_waitLongExitBySqueeze and (float_momentum < 0)
bool_exitShortWeak = strategy.position_size < 0 and not bool_waitShortExitBySqueeze and (float_momentum > 0)

bool_exitLongSqueeze = strategy.position_size > 0 and bool_waitLongExitBySqueeze and bool_squeezeBackIn
bool_exitShortSqueeze = strategy.position_size < 0 and bool_waitShortExitBySqueeze and bool_squeezeBackIn

bool_longStopHit = bool_useStopLoss and strategy.position_size > 0 and not na(float_longStopPrice) and close <= float_longStopPrice
bool_shortStopHit = bool_useStopLoss and strategy.position_size < 0 and not na(float_shortStopPrice) and close >= float_shortStopPrice

bool_longExitCondition = bool_exitLongWeak or bool_exitLongSqueeze or bool_longStopHit
bool_shortExitCondition = bool_exitShortWeak or bool_exitShortSqueeze or bool_shortStopHit

// === TRADE EXECUTION ===

// --- Entry Orders ---
if (bool_longSignalFiltered)
    strategy.entry("Long", strategy.long, qty=float_positionSize, comment="4S L SPEC")

if (bool_shortSignalFiltered)
    strategy.entry("Short", strategy.short, qty=float_positionSize, comment="4S S SPEC")

// --- Exit Orders ---
if (bool_longExitCondition)
    strategy.close("Long", comment="Exit L")

if (bool_shortExitCondition)
    strategy.close("Short", comment="Exit S")

// --- State Reset ---
if (strategy.position_size == 0)
    bool_waitLongExitBySqueeze := false
    bool_waitShortExitBySqueeze := false
    float_longStopPrice := na
    float_shortStopPrice := na

// === VISUALIZATION ===

// --- Layered Signal Display ---
plotshape(bool_showAllSignals and bool_layer1_longSignal, title="Layer 1 Long (SQZMOM)", location=location.belowbar, color=color.new(color.lime, 60), style=shape.circle, size=size.large)
plotshape(bool_showAllSignals and bool_layer1_shortSignal, title="Layer 1 Short (SQZMOM)", location=location.abovebar, color=color.new(color.red, 60), style=shape.circle, size=size.large)

plotshape(bool_showAllSignals and bool_layer2_longSignal, title="Layer 2 Long (+WT)", location=location.belowbar, color=color.new(color.green, 30), style=shape.triangleup, size=size.normal)
plotshape(bool_showAllSignals and bool_layer2_shortSignal, title="Layer 2 Short (+WT)", location=location.abovebar, color=color.new(color.red, 30), style=shape.triangledown, size=size.normal)

plotshape(bool_showAllSignals and bool_layer3_longSignal, title="Layer 3 Long (+EMA)", location=location.belowbar, color=color.new(color.blue, 20), style=shape.diamond, size=size.small)
plotshape(bool_showAllSignals and bool_layer3_shortSignal, title="Layer 3 Short (+EMA)", location=location.abovebar, color=color.new(color.purple, 20), style=shape.diamond, size=size.small)

// --- Final Trading Signals ---
plotshape(bool_longSignalFiltered, title="Final Long Entry", location=location.belowbar, color=color.new(color.green, 0), style=shape.triangleup, size=size.normal)
plotshape(bool_shortSignalFiltered, title="Final Short Entry", location=location.abovebar, color=color.new(color.red, 0), style=shape.triangledown, size=size.normal)

// --- Near Miss Signals ---
plotshape(bool_nearMissLong_EMA, title="Near Miss Long (EMA Failed)", location=location.belowbar, color=color.new(color.yellow, 40), style=shape.square, size=size.tiny)
plotshape(bool_nearMissLong_Volume, title="Near Miss Long (Volume Failed)", location=location.belowbar, color=color.new(color.orange, 40), style=shape.square, size=size.tiny)
plotshape(bool_nearMissShort_EMA, title="Near Miss Short (EMA Failed)", location=location.abovebar, color=color.new(color.yellow, 40), style=shape.square, size=size.tiny)
plotshape(bool_nearMissShort_Volume, title="Near Miss Short (Volume Failed)", location=location.abovebar, color=color.new(color.orange, 40), style=shape.square, size=size.tiny)

// --- Reversal Signals ---
plotshape(bool_reversalToLong, title="Reversal to Long", location=location.belowbar, color=color.new(color.aqua, 30), style=shape.arrowup, size=size.small)
plotshape(bool_reversalToShort, title="Reversal to Short", location=location.abovebar, color=color.new(color.fuchsia, 30), style=shape.arrowdown, size=size.small)

// --- Exit Signals ---
plotshape(bool_longExitCondition and strategy.position_size > 0, title="Exit Long", location=location.belowbar, color=color.new(color.gray, 0), style=shape.xcross, size=size.tiny)
plotshape(bool_shortExitCondition and strategy.position_size < 0, title="Exit Short", location=location.abovebar, color=color.new(color.gray, 0), style=shape.xcross, size=size.tiny)

// --- EMA Lines ---
plot(bool_useEMAFilter ? float_emaFastLine : na, "EMA Fast", color.new(color.blue, 30), 1)
plot(bool_useEMAFilter ? float_emaSlowLine : na, "EMA Slow", color.new(color.orange, 30), 1)

// --- Stop Loss Lines ---
plot(strategy.position_size > 0 and not na(float_longStopPrice) ? float_longStopPrice : na, "Long Stop", color.red, 1, plot.style_stepline)
plot(strategy.position_size < 0 and not na(float_shortStopPrice) ? float_shortStopPrice : na, "Short Stop", color.red, 1, plot.style_stepline)

// === STATUS PANEL ===

// --- Status Table Declaration ---
var table table_status = table.new(position.top_right, 2, 8, border_width=1)

// --- Status Panel Update ---
if (bool_showStatus and barstate.islast)
    table.clear(table_status)
    
    // Header
    table.cell(table_status, 0, 0, "4S v1.7 Specialist", bgcolor=color.new(color.blue, 10), text_color=color.white, text_size=size.normal)
    table.cell(table_status, 1, 0, string_signalMode + " Mode", bgcolor=color.new(color.blue, 10), text_color=color.white)
    
    // Squeeze Status
    string_sqzStatus = bool_sqzOn ? "Squeeze ON" : bool_sqzOff ? "Squeeze OFF" : "No Squeeze"
    color_sqzColor = bool_sqzOn ? color.new(color.red, 70) : bool_sqzOff ? color.new(color.green, 70) : color.new(color.gray, 70)
    table.cell(table_status, 0, 1, string_sqzStatus, bgcolor=color_sqzColor, text_color=color.white)
    table.cell(table_status, 1, 1, bool_signalBar ? "Signal âœ“" : "No Signal", bgcolor=bool_signalBar ? color.new(color.green, 70) : color.new(color.red, 70), text_color=color.white)
    
    // Momentum and WaveTrend
    table.cell(table_status, 0, 2, "Momentum: " + str.tostring(float_momentum, "#.##"), bgcolor=float_momentum > 0 ? color.new(color.green, 70) : color.new(color.red, 70), text_color=color.white)
    table.cell(table_status, 1, 2, "WT: " + (float_wt1 > float_wt2 ? "UP" : "DOWN"), bgcolor=float_wt1 > float_wt2 ? color.new(color.green, 70) : color.new(color.red, 70), text_color=color.white)
    
    // Filter Status
    string_emaStatus = bool_useEMAFilter ? (bool_emaBullTrend ? "EMA âœ“" : "EMA âœ—") : "EMA OFF"
    string_volStatus = bool_useVolumeFilter ? (bool_volumeConfirm ? "VOL âœ“" : "VOL âœ—") : "VOL OFF"
    table.cell(table_status, 0, 3, string_emaStatus, bgcolor=bool_emaBullTrend ? color.new(color.green, 70) : color.new(color.red, 70), text_color=color.white)
    table.cell(table_status, 1, 3, string_volStatus, bgcolor=bool_volumeConfirm ? color.new(color.green, 70) : color.new(color.red, 70), text_color=color.white)
    
    // Signal Layers
    table.cell(table_status, 0, 4, "L1: " + (bool_layer1_longSignal ? "âœ“" : "âœ—"), bgcolor=bool_layer1_longSignal ? color.new(color.green, 70) : color.new(color.red, 70), text_color=color.white)
    table.cell(table_status, 1, 4, "L2: " + (bool_layer2_longSignal ? "âœ“" : "âœ—"), bgcolor=bool_layer2_longSignal ? color.new(color.green, 70) : color.new(color.red, 70), text_color=color.white)
    
    table.cell(table_status, 0, 5, "L3: " + (bool_layer3_longSignal ? "âœ“" : "âœ—"), bgcolor=bool_layer3_longSignal ? color.new(color.green, 70) : color.new(color.red, 70), text_color=color.white)
    table.cell(table_status, 1, 5, "L4: " + (bool_layer4_longSignal ? "âœ“" : "âœ—"), bgcolor=bool_layer4_longSignal ? color.new(color.green, 70) : color.new(color.red, 70), text_color=color.white)
    
    // Final Signal
    table.cell(table_status, 0, 6, "Final Signal", text_color=color.black)
    table.cell(table_status, 1, 6, bool_longSignalFiltered ? "LONG âœ“" : bool_shortSignalFiltered ? "SHORT âœ“" : "NONE", bgcolor=bool_longSignalFiltered ? color.new(color.green, 70) : bool_shortSignalFiltered ? color.new(color.red, 70) : color.new(color.gray, 70), text_color=color.white)
    
    // Position Status
    string_posStatus = strategy.position_size > 0 ? "LONG" : strategy.position_size < 0 ? "SHORT" : "FLAT"
    table.cell(table_status, 0, 7, "Position", text_color=color.black)
    table.cell(table_status, 1, 7, string_posStatus, bgcolor=strategy.position_size > 0 ? color.new(color.green, 70) : strategy.position_size < 0 ? color.new(color.red, 70) : color.new(color.gray, 70), text_color=color.white)

// === ALERT CONDITIONS ===
alertcondition(bool_longSignalFiltered, "Long Signal", "4S v1.7 Specialist: Long signal detected!")
alertcondition(bool_shortSignalFiltered, "Short Signal", "4S v1.7 Specialist: Short signal detected!")
alertcondition(bool_layer2_longSignal, "Core Long Signal", "4S v1.7 Specialist: Core long signal (SQZMOM+WT)!")
alertcondition(bool_nearMissLong_EMA or bool_nearMissLong_Volume, "Near Miss Long", "4S v1.7 Specialist: Near miss long signal!")
alertcondition(bool_reversalToLong or bool_reversalToShort, "Reversal Signal", "4S v1.7 Specialist: Reversal signal detected!")
alertcondition(bool_longExitCondition or bool_shortExitCondition, "Exit Signal", "4S v1.7 Specialist: Exit signal triggered!")